<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chat</title>
    <link rel="stylesheet" href="tailwind.css">
    <style>
        /* Custom scrollbar for WebKit browsers (Chrome, Safari, VS Code) */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }

        /* Ensure proper flex layout for chat */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        /* WhatsApp-style message bubbles */
        .message-bubble {
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        /* Scroll to bottom button */
        #scroll-to-bottom {
            transition: opacity 0.2s, transform 0.2s;
        }
        #scroll-to-bottom:hover {
            transform: scale(1.1);
        }

        /* Unread badge animation */
        .unread-badge {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 h-screen overflow-hidden">
    <div class="flex h-full">
        <!-- Main Chat Area -->
        <div class="flex flex-col flex-1">

            <!-- ============================================================ -->
            <!-- STATE PANEL: Idle ‚Äî Start / Join buttons                     -->
            <!-- ============================================================ -->
            <div id="panel-idle" class="hidden flex-1 flex flex-col items-center justify-center gap-4 px-6">
                <h2 class="text-lg font-semibold text-white">Conductor</h2>
                <p class="text-sm text-gray-400 text-center">Start a new session or join an existing one.</p>
                <button
                    id="btn-idle-start"
                    class="bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium px-6 py-2 rounded-lg flex items-center gap-2"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                    </svg>
                    Start
                </button>
                <div class="flex items-center gap-2 w-full max-w-xs">
                    <input
                        id="invite-url-input"
                        type="text"
                        placeholder="Paste invite link‚Ä¶"
                        class="flex-1 bg-gray-700 text-white text-xs px-3 py-1.5 rounded-lg border border-gray-600 focus:outline-none focus:border-blue-500"
                    />
                    <button
                        id="btn-idle-join"
                        class="bg-green-600 hover:bg-green-700 text-white text-xs font-medium px-3 py-1.5 rounded-lg flex items-center gap-1"
                    >
                        Join
                    </button>
                </div>
            </div>

            <!-- ============================================================ -->
            <!-- STATE PANEL: BackendDisconnected ‚Äî join only mode            -->
            <!-- ============================================================ -->
            <div id="panel-disconnected" class="hidden flex-1 flex flex-col items-center justify-center gap-4 px-6">
                <!-- Backend status warning -->
                <div class="flex items-center gap-2 text-amber-400 mb-2">
                    <span class="text-xl">‚ö†</span>
                    <span class="text-sm font-medium">Local backend not running</span>
                </div>

                <h2 class="text-lg font-semibold text-white">Join Only Mode</h2>
                <p class="text-sm text-gray-400 text-center max-w-xs">
                    You can join other people's sessions. To start your own session, please start the backend first.
                </p>

                <!-- Start Session button (disabled) -->
                <div class="relative group w-full max-w-xs">
                    <button
                        id="btn-start-session-disabled"
                        disabled
                        class="w-full bg-gray-600 text-gray-400 text-sm font-medium px-6 py-2 rounded-lg flex items-center justify-center gap-2 cursor-not-allowed opacity-60"
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                        </svg>
                        Start Session
                    </button>
                    <!-- Tooltip -->
                    <div class="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-1.5 bg-gray-900 text-white text-xs rounded-lg opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap pointer-events-none">
                        Backend required to host a session
                        <div class="absolute top-full left-1/2 transform -translate-x-1/2 border-4 border-transparent border-t-gray-900"></div>
                    </div>
                </div>

                <!-- Join Session input + button -->
                <div class="flex items-center gap-2 w-full max-w-xs">
                    <input
                        id="disconnected-invite-url-input"
                        type="text"
                        placeholder="Paste invite link‚Ä¶"
                        class="flex-1 bg-gray-700 text-white text-xs px-3 py-1.5 rounded-lg border border-gray-600 focus:outline-none focus:border-green-500"
                    />
                    <button
                        id="btn-disconnected-join"
                        class="bg-green-600 hover:bg-green-700 text-white text-xs font-medium px-3 py-1.5 rounded-lg flex items-center gap-1"
                    >
                        Join
                    </button>
                </div>

                <!-- Retry connection link -->
                <button
                    id="btn-retry"
                    class="text-blue-400 hover:text-blue-300 text-xs underline mt-2"
                >
                    Retry backend connection
                </button>
            </div>

            <!-- ============================================================ -->
            <!-- STATE PANEL: ReadyToHost ‚Äî start session                     -->
            <!-- ============================================================ -->
            <div id="panel-ready" class="hidden flex-1 flex flex-col items-center justify-center gap-4 px-6">
                <h2 class="text-lg font-semibold text-white">Ready</h2>
                <p class="text-sm text-gray-400 text-center">Backend connected. Start a session or join an existing one.</p>
                <button
                    id="btn-start-session"
                    class="bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium px-6 py-2 rounded-lg flex items-center gap-2"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                    </svg>
                    Start Session
                </button>
                <div class="flex items-center gap-2 w-full max-w-xs">
                    <input
                        id="ready-invite-url-input"
                        type="text"
                        placeholder="Paste invite link‚Ä¶"
                        class="flex-1 bg-gray-700 text-white text-xs px-3 py-1.5 rounded-lg border border-gray-600 focus:outline-none focus:border-blue-500"
                    />
                    <button
                        id="btn-ready-join"
                        class="bg-green-600 hover:bg-green-700 text-white text-xs font-medium px-3 py-1.5 rounded-lg flex items-center gap-1"
                    >
                        Join
                    </button>
                </div>
            </div>

            <!-- ============================================================ -->
            <!-- STATE PANEL: Joining ‚Äî loading indicator                     -->
            <!-- ============================================================ -->
            <div id="panel-joining" class="hidden flex-1 flex flex-col items-center justify-center gap-3 px-6">
                <div class="h-8 w-8 border-4 border-blue-400 border-t-transparent rounded-full animate-spin"></div>
                <p class="text-sm text-gray-400">Joining session‚Ä¶</p>
            </div>

            <!-- ============================================================ -->
            <!-- STATE PANELS: Hosting / Joined ‚Äî full chat UI                -->
            <!-- ============================================================ -->
            <div id="panel-chat" class="hidden flex flex-1 min-h-0">
            <!-- Chat content column (header + messages + input) -->
            <div class="flex flex-col flex-1 min-h-0 overflow-hidden">

            <!-- Header (only visible in Hosting / Joined) -->
            <header class="bg-gray-800 border-b border-gray-700 px-6 py-4 flex-shrink-0">
                <div class="flex items-center justify-between">
                    <div>
                        <h1 class="text-xl font-semibold text-white">AI Chat Assistant</h1>
                        <p class="text-sm text-gray-400 mt-1 flex items-center gap-1">
                            Room: <span id="room-id-display" class="font-mono text-xs text-gray-500">loading...</span>
                            <button id="btn-copy-room-id" class="text-gray-500 hover:text-gray-300 transition-colors p-0.5" title="Copy Room ID">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-3.5 w-3.5" viewBox="0 0 20 20" fill="currentColor">
                                    <path d="M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z" />
                                    <path d="M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z" />
                                </svg>
                            </button>
                        </p>
                    </div>
                    <div class="flex items-center gap-3">
                        <!-- Auto Apply Toggle (Lead only) -->
                        <div id="auto-apply-toggle-container" class="hidden flex items-center gap-2">
                            <span class="text-xs text-gray-400">Auto</span>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="auto-apply-toggle" class="sr-only peer">
                                <div class="w-9 h-5 bg-gray-600 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-amber-500 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-amber-600"></div>
                            </label>
                        </div>
                        <div id="role-badge" class="px-3 py-1 rounded-full text-xs font-medium bg-gray-700 text-gray-300">
                            <!-- Role badge will be updated by JavaScript -->
                        </div>
                    </div>
                </div>

            <!-- Hosting-only controls: invite + stop -->
            <div id="hosting-controls" class="hidden mt-4 flex items-center gap-2">
                <span class="text-xs text-green-400 flex items-center gap-1">
                    <span class="inline-block h-2 w-2 rounded-full bg-green-400"></span>
                    Hosting
                </span>
                <button
                    id="btn-copy-invite"
                    class="bg-indigo-600 hover:bg-indigo-700 text-white text-xs font-medium px-3 py-1.5 rounded-lg flex items-center gap-1"
                >
                    Copy Invite Link
                </button>
                <button
                    id="btn-stop-session"
                    class="bg-gray-600 hover:bg-gray-500 text-white text-xs font-medium px-3 py-1.5 rounded-lg"
                >
                    Stop
                </button>
            </div>

            <!-- Joined-only controls: leave -->
            <div id="joined-controls" class="hidden mt-4 flex items-center gap-2">
                <span class="text-xs text-blue-400 flex items-center gap-1">
                    <span class="inline-block h-2 w-2 rounded-full bg-blue-400"></span>
                    Joined
                </span>
                <button
                    id="btn-leave-session"
                    class="bg-gray-600 hover:bg-gray-500 text-white text-xs font-medium px-3 py-1.5 rounded-lg"
                >
                    Leave
                </button>
            </div>

            <!-- Lead-only Action Buttons -->
            <div id="lead-actions" class="hidden mt-4 flex gap-2">
                <button
                    id="btn-create-summary"
                    class="bg-emerald-600 hover:bg-emerald-700 text-white text-sm font-medium px-4 py-2 rounded-lg transition-colors duration-200 flex items-center gap-2"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4zm2 6a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1zm1 3a1 1 0 100 2h6a1 1 0 100-2H7z" clip-rule="evenodd" />
                    </svg>
                    Create Summary
                </button>
                <button
                    id="btn-generate-changes"
                    class="bg-purple-600 hover:bg-purple-700 text-white text-sm font-medium px-4 py-2 rounded-lg transition-colors duration-200 flex items-center gap-2"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M12.316 3.051a1 1 0 01.633 1.265l-4 12a1 1 0 11-1.898-.632l4-12a1 1 0 011.265-.633zM5.707 6.293a1 1 0 010 1.414L3.414 10l2.293 2.293a1 1 0 11-1.414 1.414l-3-3a1 1 0 010-1.414l3-3a1 1 0 011.414 0zm8.586 0a1 1 0 011.414 0l3 3a1 1 0 010 1.414l-3 3a1 1 0 11-1.414-1.414L16.586 10l-2.293-2.293a1 1 0 010-1.414z" clip-rule="evenodd" />
                    </svg>
                    Generate Changes
                </button>
                <button
                    id="btn-end-chat"
                    class="bg-red-600 hover:bg-red-700 text-white text-sm font-medium px-4 py-2 rounded-lg transition-colors duration-200 flex items-center gap-2"
                    title="End chat session for all participants"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
                    </svg>
                    End Chat
                </button>
            </div>

            <!-- Pending Changes Card (hidden by default) -->
            <div id="pending-changes-card" class="hidden mt-4 bg-gray-700/50 border border-gray-600 rounded-lg p-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-medium text-white flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-purple-400" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd" />
                        </svg>
                        <span id="pending-changes-title">Pending Changes</span>
                        <span id="change-progress" class="text-purple-300 text-xs font-normal"></span>
                    </h3>
                    <button id="btn-discard-changes" class="text-gray-400 hover:text-gray-200 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                        </svg>
                    </button>
                </div>

                <!-- Current File Info -->
                <div id="current-file-info" class="text-xs text-blue-300 mb-2 flex items-center gap-1">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-3.5 w-3.5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4z" clip-rule="evenodd" />
                    </svg>
                    <span id="current-file-name"></span>
                </div>

                <!-- Change Stats -->
                <div class="flex items-center gap-4 text-xs text-gray-300 mb-3">
                    <span id="pending-files-count" class="flex items-center gap-1">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-3.5 w-3.5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4z" clip-rule="evenodd" />
                        </svg>
                        <span>1 file</span>
                    </span>
                    <span id="pending-lines-count" class="flex items-center gap-1">
                        <span class="text-green-400">+5</span>
                        <span class="text-red-400">-3</span>
                        <span>lines</span>
                    </span>
                </div>

                <!-- Policy Status -->
                <div id="policy-status" class="flex items-center gap-2 text-xs mb-3">
                    <span id="policy-status-icon" class="text-green-400">‚úì</span>
                    <span id="policy-status-text" class="text-gray-300">Safe to apply</span>
                </div>

                <!-- Action Buttons -->
                <div class="flex gap-2">
                    <button
                        id="btn-view-diff"
                        class="flex-1 bg-gray-600 hover:bg-gray-500 text-white text-xs font-medium px-3 py-2 rounded-lg transition-colors duration-200 flex items-center justify-center gap-1"
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-3.5 w-3.5" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
                            <path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd" />
                        </svg>
                        View Diff
                    </button>
                    <button
                        id="btn-apply-changes"
                        class="flex-1 bg-green-600 hover:bg-green-700 text-white text-xs font-medium px-3 py-2 rounded-lg transition-colors duration-200 flex items-center justify-center gap-1"
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-3.5 w-3.5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
                        </svg>
                        Apply
                    </button>
                </div>
            </div>
        </header>

        <!-- Messages Area - WhatsApp-style scrollable container -->
        <div class="relative flex-1 min-h-0">
            <div id="messages-container" class="absolute inset-0 overflow-y-auto px-4 py-4 space-y-3" style="scrollbar-width: thin; scrollbar-color: #4b5563 transparent;">
                <!-- Messages will be rendered here by JavaScript -->
                <div id="connection-status" class="flex justify-center">
                    <div class="bg-gray-800/50 text-gray-400 text-xs px-3 py-1.5 rounded-full border border-gray-700">
                        <span>Connecting to chat...</span>
                    </div>
                </div>
            </div>

            <!-- Scroll to bottom button -->
            <button id="scroll-to-bottom" class="hidden absolute bottom-4 right-4 bg-gray-700 hover:bg-gray-600 text-white p-2 rounded-full shadow-lg z-10" title="Scroll to bottom">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
                </svg>
                <span id="unread-count" class="hidden absolute -top-1 -right-1 bg-blue-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center unread-badge">0</span>
            </button>
        </div>

        <!-- Typing Indicator -->
        <div id="typing-indicator" class="hidden flex-shrink-0 px-6 py-2 text-xs text-gray-400 italic">
            <span id="typing-text">Someone is typing...</span>
        </div>

        <!-- Input Area -->
        <div class="flex-shrink-0 border-t border-gray-700 bg-gray-800 px-6 py-4">
            <!-- Hidden file input -->
            <input type="file" id="file-input" class="hidden"
                   accept="image/*,.pdf,audio/*,.mp3,.wav,.ogg,.m4a,.flac" />

            <!-- File preview area (shown when file is selected) -->
            <div id="file-preview" class="hidden mb-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                <div class="flex items-center justify-between">
                    <div class="flex items-center gap-3">
                        <span id="file-preview-icon" class="text-2xl">üìé</span>
                        <div>
                            <div id="file-preview-name" class="text-sm text-gray-200 font-medium"></div>
                            <div id="file-preview-size" class="text-xs text-gray-500"></div>
                        </div>
                    </div>
                    <div class="flex items-center gap-2">
                        <!-- Upload button -->
                        <button id="btn-upload-file" class="bg-green-600 hover:bg-green-700 text-white text-sm font-medium px-3 py-1.5 rounded-lg transition-colors">
                            ‚¨ÜÔ∏è Upload
                        </button>
                        <!-- Cancel button -->
                        <button id="btn-remove-file" class="text-gray-400 hover:text-red-400 p-1" title="Cancel">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                            </svg>
                        </button>
                    </div>
                </div>
                <!-- Image preview thumbnail -->
                <img id="file-preview-img" class="hidden mt-3 max-h-32 rounded-lg" />
                <!-- Optional caption input -->
                <div class="mt-2">
                    <input type="text" id="file-caption" placeholder="Add a caption (optional)..."
                           class="w-full bg-gray-800 text-gray-100 border border-gray-600 rounded px-3 py-1.5 text-sm focus:outline-none focus:ring-1 focus:ring-blue-500" />
                </div>
            </div>

            <!-- Code Snippet Preview (shown when code is attached) -->
            <div id="code-snippet-preview" class="hidden mb-3 bg-gray-800 border border-gray-600 rounded-lg overflow-hidden">
                <div class="flex items-center justify-between px-3 py-2 bg-gray-700 border-b border-gray-600">
                    <div class="flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-blue-400" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M12.316 3.051a1 1 0 01.633 1.265l-4 12a1 1 0 11-1.898-.632l4-12a1 1 0 011.265-.633zM5.707 6.293a1 1 0 010 1.414L3.414 10l2.293 2.293a1 1 0 11-1.414 1.414l-3-3a1 1 0 010-1.414l3-3a1 1 0 011.414 0zm8.586 0a1 1 0 011.414 0l3 3a1 1 0 010 1.414l-3 3a1 1 0 11-1.414-1.414L16.586 10l-2.293-2.293a1 1 0 010-1.414z" clip-rule="evenodd" />
                        </svg>
                        <span id="code-snippet-filename" class="text-xs text-gray-300 font-mono truncate max-w-[200px]"></span>
                        <span id="code-snippet-lines" class="text-xs text-gray-500"></span>
                    </div>
                    <button id="btn-clear-snippet" class="text-gray-400 hover:text-white p-1" title="Remove code snippet">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                        </svg>
                    </button>
                </div>
                <pre id="code-snippet-content" class="p-3 text-xs font-mono text-gray-300 overflow-x-auto max-h-32 overflow-y-auto"></pre>
            </div>

            <div class="flex items-end gap-3">
                <!-- Attachment Button -->
                <button
                    id="btn-attach"
                    class="bg-gray-700 hover:bg-gray-600 text-gray-300 p-3 rounded-lg transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-500"
                    title="Attach file (images, PDF, audio, max 20MB)"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M8 4a3 3 0 00-3 3v4a5 5 0 0010 0V7a1 1 0 112 0v4a7 7 0 11-14 0V7a5 5 0 0110 0v4a3 3 0 11-6 0V7a1 1 0 012 0v4a1 1 0 102 0V7a3 3 0 00-3-3z" clip-rule="evenodd" />
                    </svg>
                </button>

                <!-- Code Snippet Button -->
                <button
                    id="btn-code-snippet"
                    class="bg-gray-700 hover:bg-gray-600 text-gray-300 p-3 rounded-lg transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-500"
                    title="Share code from editor (select code first)"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M12.316 3.051a1 1 0 01.633 1.265l-4 12a1 1 0 11-1.898-.632l4-12a1 1 0 011.265-.633zM5.707 6.293a1 1 0 010 1.414L3.414 10l2.293 2.293a1 1 0 11-1.414 1.414l-3-3a1 1 0 010-1.414l3-3a1 1 0 011.414 0zm8.586 0a1 1 0 011.414 0l3 3a1 1 0 010 1.414l-3 3a1 1 0 11-1.414-1.414L16.586 10l-2.293-2.293a1 1 0 010-1.414z" clip-rule="evenodd" />
                    </svg>
                </button>

                <!-- Text Input -->
                <div class="flex-1">
                    <textarea
                        id="chat-input"
                        rows="1"
                        placeholder="Type your message or paste an image..."
                        class="w-full bg-gray-900 text-gray-100 border border-gray-700 rounded-lg px-4 py-3 resize-none focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent placeholder-gray-500 text-sm"
                    ></textarea>
                </div>

                <!-- Send Button -->
                <button
                    id="btn-send"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-medium px-6 py-3 rounded-lg transition-colors duration-200 flex items-center gap-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" />
                    </svg>
                    <span class="text-sm">Send</span>
                </button>
            </div>

            <!-- Helper Text -->
            <div class="mt-2 text-xs text-gray-500">
                Press Enter to send, Shift+Enter for new line. Click <span class="text-blue-400">&lt;/&gt;</span> to share code from editor.
            </div>
        </div>
        </div> <!-- close chat content column -->

        <!-- Users Sidebar (inside panel-chat) -->
        <aside id="sidebar" class="w-56 bg-gray-800 border-l border-gray-700 flex-shrink-0 hidden md:flex flex-col">
            <div class="px-4 py-4 border-b border-gray-700">
                <div class="flex items-center justify-between">
                    <h2 class="text-sm font-semibold text-gray-300">Participants</h2>
                    <span id="user-count" class="text-xs text-gray-400 bg-gray-700 px-2 py-0.5 rounded-full">0</span>
                </div>
            </div>
            <div id="users-list" class="flex-1 overflow-y-auto p-2 space-y-1">
                <!-- Users will be rendered here -->
            </div>
            <!-- Room Info Footer -->
            <div class="px-3 py-3 border-t border-gray-700 bg-gray-800/50">
                <div class="text-xs text-gray-500 truncate" id="room-id-display" title="">
                    Room: <span class="text-gray-400 font-mono">--</span>
                </div>
            </div>
        </aside>
        </div> <!-- close panel-chat -->
    </div> <!-- close main area flex-col -->
    </div> <!-- close outer flex h-full -->

    <script>
        // VS Code API for communication with the extension
        const vscode = acquireVsCodeApi();

        // Session state (injected by extension)
        let session = window.initialSession || { roomId: null, hostId: null, userId: null, createdAt: null, backendUrl: 'http://localhost:8000', displayName: 'Host' };
        console.log('[WebView] Session initialized:', session.roomId ? `roomId=${session.roomId}, userId=${session.userId}` : 'no session');

        // Conductor FSM state (injected by extension)
        let conductorState = window.initialConductorState || 'Idle';
        console.log('[WebView] Conductor state:', conductorState);

        // Users map: userId -> user info
        const usersMap = new Map();

        // Display roomId in the header (truncated for readability)
        const roomIdDisplay = document.getElementById('room-id-display');
        if (roomIdDisplay && session.roomId) {
            roomIdDisplay.textContent = session.roomId.substring(0, 8) + '...';
            roomIdDisplay.title = session.roomId; // Full ID on hover
        }

        // State
        let pendingChangeSet = null;
        let policyResult = null;
        let autoApplyEnabled = false;
        let currentChange = null;
        let currentChangeIndex = 0;
        let totalChanges = 0;

        // WebSocket state
        let ws = null;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 10;
        const BASE_RECONNECT_DELAY_MS = 1000;
        const MAX_RECONNECT_DELAY_MS = 30000;

        // Message recovery & deduplication
        let lastMessageTimestamp = 0;
        const seenMessageIds = new Set();

        // DOM elements
        const roleBadge = document.getElementById('role-badge');
        const leadActions = document.getElementById('lead-actions');
        const btnCreateSummary = document.getElementById('btn-create-summary');
        const btnGenerateChanges = document.getElementById('btn-generate-changes');
        const autoApplyToggleContainer = document.getElementById('auto-apply-toggle-container');
        const autoApplyToggle = document.getElementById('auto-apply-toggle');
        const pendingChangesCard = document.getElementById('pending-changes-card');
        const pendingFilesCount = document.getElementById('pending-files-count');
        const pendingLinesCount = document.getElementById('pending-lines-count');
        const policyStatus = document.getElementById('policy-status');
        const policyStatusIcon = document.getElementById('policy-status-icon');
        const policyStatusText = document.getElementById('policy-status-text');
        const btnViewDiff = document.getElementById('btn-view-diff');
        const btnApplyChanges = document.getElementById('btn-apply-changes');
        const btnDiscardChanges = document.getElementById('btn-discard-changes');
        const changeProgress = document.getElementById('change-progress');
        const currentFileInfo = document.getElementById('current-file-info');
        const currentFileName = document.getElementById('current-file-name');
        const messagesContainer = document.getElementById('messages-container');
        const connectionStatus = document.getElementById('connection-status');
        const chatInput = document.getElementById('chat-input');
        const btnSend = document.getElementById('btn-send');
        const btnCopyRoomId = document.getElementById('btn-copy-room-id');
        const btnEndChat = document.getElementById('btn-end-chat');
        const usersList = document.getElementById('users-list');
        const userCount = document.getElementById('user-count');

        // State panels (render() toggles these)
        const panelIdle = document.getElementById('panel-idle');
        const panelDisconnected = document.getElementById('panel-disconnected');
        const panelReady = document.getElementById('panel-ready');
        const panelJoining = document.getElementById('panel-joining');
        const panelChat = document.getElementById('panel-chat');
        const hostingControls = document.getElementById('hosting-controls');
        const joinedControls = document.getElementById('joined-controls');

        // Buttons inside state panels
        const btnIdleStart = document.getElementById('btn-idle-start');
        const btnIdleJoin = document.getElementById('btn-idle-join');
        const btnRetry = document.getElementById('btn-retry');
        const btnStartSession = document.getElementById('btn-start-session');
        const btnReadyJoin = document.getElementById('btn-ready-join');
        const readyInviteUrlInput = document.getElementById('ready-invite-url-input');
        const btnDisconnectedJoin = document.getElementById('btn-disconnected-join');
        const disconnectedInviteUrlInput = document.getElementById('disconnected-invite-url-input');
        const btnStopSession = document.getElementById('btn-stop-session');
        const btnCopyInvite = document.getElementById('btn-copy-invite');
        const inviteUrlInput = document.getElementById('invite-url-input');
        const btnLeaveSession = document.getElementById('btn-leave-session');

        // File upload elements
        const fileInput = document.getElementById('file-input');
        const filePreview = document.getElementById('file-preview');
        const filePreviewIcon = document.getElementById('file-preview-icon');
        const filePreviewName = document.getElementById('file-preview-name');
        const filePreviewSize = document.getElementById('file-preview-size');
        const filePreviewImg = document.getElementById('file-preview-img');
        const fileCaption = document.getElementById('file-caption');
        const btnAttach = document.getElementById('btn-attach');
        const btnRemoveFile = document.getElementById('btn-remove-file');
        const btnUploadFile = document.getElementById('btn-upload-file');

        // Code snippet elements
        const btnCodeSnippet = document.getElementById('btn-code-snippet');
        const codeSnippetPreview = document.getElementById('code-snippet-preview');
        const codeSnippetFilename = document.getElementById('code-snippet-filename');
        const codeSnippetLines = document.getElementById('code-snippet-lines');
        const codeSnippetContent = document.getElementById('code-snippet-content');
        const btnClearSnippet = document.getElementById('btn-clear-snippet');

        // Track session state
        let sessionEnded = false;

        // Track pending code snippet
        let pendingCodeSnippet = null;

        // Track pending file upload
        let pendingFile = null;
        let isUploading = false;  // Prevent double uploads
        const MAX_FILE_SIZE = 20 * 1024 * 1024; // 20MB

        // Typing indicator state
        const typingIndicator = document.getElementById('typing-indicator');
        const typingText = document.getElementById('typing-text');
        const typingUsers = new Map();  // userId -> displayName
        let typingTimeout = null;
        const TYPING_DEBOUNCE_MS = 500;
        const TYPING_EXPIRE_MS = 3000;
        let isTyping = false;
        let lastTypingTime = 0;

        // Message grouping state
        let lastMessageUserId = null;
        let lastMessageTime = 0;
        let lastMessageDate = null;
        const MESSAGE_GROUP_INTERVAL_MS = 5 * 60 * 1000;  // 5 minutes

        // Scroll to bottom button state
        const scrollToBottomBtn = document.getElementById('scroll-to-bottom');
        const unreadCountBadge = document.getElementById('unread-count');
        let unreadCount = 0;
        let isUserScrolledUp = false;
        const SCROLL_THRESHOLD = 100;  // pixels from bottom to consider "at bottom"

        // Pagination state
        let isLoadingHistory = false;
        let hasMoreHistory = true;
        const PAGINATION_THRESHOLD = 100;  // pixels from top to trigger load

        // Avatar color mapping
        const avatarColors = {
            purple: 'bg-purple-600',
            blue: 'bg-blue-600',
            green: 'bg-green-600',
            orange: 'bg-orange-600',
            pink: 'bg-pink-600',
            cyan: 'bg-cyan-600',
            yellow: 'bg-yellow-600',
            red: 'bg-red-600',
            amber: 'bg-amber-500'
        };

        /**
         * Update the UI based on permissions.
         */
        function updateUIForPermissions(permissions) {
            // Store session role for use in messages
            if (permissions.sessionRole) {
                session.sessionRole = permissions.sessionRole;
            }

            // Update role badge based on session role (host/guest) or config role (lead/member)
            if (permissions.sessionRole === 'host') {
                roleBadge.textContent = 'üëë Host';
                roleBadge.className = 'px-3 py-1 rounded-full text-xs font-medium bg-amber-600 text-white';
            } else if (permissions.sessionRole === 'guest') {
                roleBadge.textContent = 'üë§ Guest';
                roleBadge.className = 'px-3 py-1 rounded-full text-xs font-medium bg-blue-600 text-white';
            } else if (permissions.role === 'lead') {
                roleBadge.textContent = 'üëë Lead';
                roleBadge.className = 'px-3 py-1 rounded-full text-xs font-medium bg-amber-600 text-white';
            } else {
                roleBadge.textContent = 'üë§ Member';
                roleBadge.className = 'px-3 py-1 rounded-full text-xs font-medium bg-gray-700 text-gray-300';
            }

            // Show/hide lead-only actions (show if any lead action is available OR if lead role)
            // End Chat button is always available for leads
            if (permissions.role === 'lead' || permissions.canCreateSummary || permissions.canGenerateChanges) {
                leadActions.classList.remove('hidden');
                leadActions.classList.add('flex');
            } else {
                leadActions.classList.add('hidden');
                leadActions.classList.remove('flex');
            }

            // Individual button visibility
            btnCreateSummary.style.display = permissions.canCreateSummary ? 'flex' : 'none';
            btnGenerateChanges.style.display = permissions.canGenerateChanges ? 'flex' : 'none';
            // End Chat button is always visible for leads
            btnEndChat.style.display = permissions.role === 'lead' ? 'flex' : 'none';

            // Show auto-apply toggle for leads
            if (permissions.canAutoApply) {
                autoApplyToggleContainer.classList.remove('hidden');
                autoApplyToggleContainer.classList.add('flex');
            } else {
                autoApplyToggleContainer.classList.add('hidden');
                autoApplyToggleContainer.classList.remove('flex');
            }
        }

        /**
         * Single render function ‚Äî deterministically updates the entire UI
         * based on the ConductorState. No conditional UI logic exists
         * outside this function.
         */
        function render(state, newSession) {
            const prevState = conductorState;
            conductorState = state;

            // Track if roomId changed (need to reconnect WebSocket)
            const prevRoomId = session.roomId;

            // Update session data if provided (e.g. after startHosting or joinSucceeded)
            if (newSession) {
                session = { ...session, ...newSession };
                if (roomIdDisplay && session.roomId) {
                    roomIdDisplay.textContent = session.roomId.substring(0, 8) + '...';
                    roomIdDisplay.title = session.roomId;
                }
            }

            const roomIdChanged = newSession && newSession.roomId && newSession.roomId !== prevRoomId;

            // --- 1. Hide every panel ----------------------------------------
            panelIdle.classList.add('hidden');
            panelIdle.classList.remove('flex');
            panelDisconnected.classList.add('hidden');
            panelDisconnected.classList.remove('flex');
            panelReady.classList.add('hidden');
            panelReady.classList.remove('flex');
            panelJoining.classList.add('hidden');
            panelJoining.classList.remove('flex');
            panelChat.classList.add('hidden');
            panelChat.classList.remove('flex');
            hostingControls.classList.add('hidden');
            hostingControls.classList.remove('flex');
            joinedControls.classList.add('hidden');
            joinedControls.classList.remove('flex');

            // --- 2. Show the panel for the current state --------------------
            if (state === 'Idle') {
                panelIdle.classList.remove('hidden');
                panelIdle.classList.add('flex');
            } else if (state === 'BackendDisconnected') {
                panelDisconnected.classList.remove('hidden');
                panelDisconnected.classList.add('flex');
            } else if (state === 'ReadyToHost') {
                panelReady.classList.remove('hidden');
                panelReady.classList.add('flex');
            } else if (state === 'Joining') {
                panelJoining.classList.remove('hidden');
                panelJoining.classList.add('flex');
            } else if (state === 'Hosting') {
                panelChat.classList.remove('hidden');
                panelChat.classList.add('flex');
                hostingControls.classList.remove('hidden');
                hostingControls.classList.add('flex');
            } else if (state === 'Joined') {
                panelChat.classList.remove('hidden');
                panelChat.classList.add('flex');
                joinedControls.classList.remove('hidden');
                joinedControls.classList.add('flex');
            }

            // --- 3. WebSocket lifecycle -------------------------------------
            const chatStates = ['Hosting', 'Joined'];
            const wasInChat = chatStates.includes(prevState);
            const nowInChat = chatStates.includes(state);

            if (nowInChat && !wasInChat) {
                // Entering chat state ‚Äî connect
                connectWebSocket();
            } else if (!nowInChat && wasInChat) {
                // Leaving chat state ‚Äî disconnect
                disconnectWebSocket();
            } else if (nowInChat && wasInChat && roomIdChanged) {
                // Staying in chat but roomId changed ‚Äî reconnect to new room
                console.log('[WebView] roomId changed, reconnecting WebSocket');
                disconnectWebSocket();
                connectWebSocket();
            }

            console.log('[WebView] render:', prevState, '‚Üí', state, roomIdChanged ? '(roomId changed)' : '');
        }

        /**
         * Disconnect the WebSocket if open.
         */
        function disconnectWebSocket() {
            if (ws) {
                console.log('[WebView] Disconnecting WebSocket');
                ws.close();
                ws = null;
            }
        }

        /**
         * Update the pending changes card UI.
         */
        function updatePendingChangesCard(changeSet, policy) {
            if (!changeSet) {
                pendingChangesCard.classList.add('hidden');
                return;
            }

            pendingChangesCard.classList.remove('hidden');

            // Update file count
            const filesCount = changeSet.changes ? changeSet.changes.length : 0;
            pendingFilesCount.querySelector('span').textContent = `${filesCount} file${filesCount !== 1 ? 's' : ''}`;

            // Update lines count
            let linesAdded = 0;
            let linesRemoved = 0;
            if (changeSet.changes) {
                for (const change of changeSet.changes) {
                    if (change.type === 'replace_range' && change.range) {
                        linesRemoved += change.range.end - change.range.start + 1;
                        linesAdded += (change.content || '').split('\n').length;
                    } else if (change.type === 'create_file') {
                        linesAdded += (change.content || '').split('\n').length;
                    }
                }
            }
            pendingLinesCount.innerHTML = `
                <span class="text-green-400">+${linesAdded}</span>
                <span class="text-red-400">-${linesRemoved}</span>
                <span>lines</span>
            `;

            // Update policy status
            if (policy) {
                if (policy.allowed) {
                    policyStatusIcon.textContent = '‚úì';
                    policyStatusIcon.className = 'text-green-400';
                    policyStatusText.textContent = 'Safe to apply';
                    policyStatusText.className = 'text-gray-300';
                    btnApplyChanges.disabled = false;
                    btnApplyChanges.className = 'flex-1 bg-green-600 hover:bg-green-700 text-white text-xs font-medium px-3 py-2 rounded-lg transition-colors duration-200 flex items-center justify-center gap-1';
                } else {
                    policyStatusIcon.textContent = '‚ö†';
                    policyStatusIcon.className = 'text-amber-400';
                    policyStatusText.textContent = policy.reasons ? policy.reasons.join('; ') : 'Manual review required';
                    policyStatusText.className = 'text-amber-300';
                    // Still allow manual apply, but show warning
                    btnApplyChanges.disabled = false;
                    btnApplyChanges.className = 'flex-1 bg-amber-600 hover:bg-amber-700 text-white text-xs font-medium px-3 py-2 rounded-lg transition-colors duration-200 flex items-center justify-center gap-1';
                }
            }
        }

        /**
         * Clear pending changes.
         */
        function clearPendingChanges() {
            pendingChangeSet = null;
            policyResult = null;
            currentChange = null;
            currentChangeIndex = 0;
            totalChanges = 0;
            pendingChangesCard.classList.add('hidden');
        }

        /**
         * Update UI for the current change being reviewed.
         */
        function updateCurrentChangeUI(change, index, total, policy) {
            if (!change) {
                pendingChangesCard.classList.add('hidden');
                return;
            }

            pendingChangesCard.classList.remove('hidden');
            currentChange = change;
            currentChangeIndex = index;
            totalChanges = total;
            policyResult = policy;

            // Update progress indicator (e.g., "1/3")
            changeProgress.textContent = `(${index + 1}/${total})`;

            // Update current file name
            currentFileName.textContent = change.file;
            currentFileInfo.classList.remove('hidden');

            // Update file count to show current/total
            pendingFilesCount.querySelector('span').textContent = `Change ${index + 1} of ${total}`;

            // Calculate lines for this single change
            let linesAdded = 0;
            let linesRemoved = 0;
            if (change.type === 'replace_range' && change.range) {
                linesRemoved = change.range.end - change.range.start + 1;
                linesAdded = (change.content || '').split('\n').length;
            } else if (change.type === 'create_file') {
                linesAdded = (change.content || '').split('\n').length;
            }
            pendingLinesCount.innerHTML = `
                <span class="text-green-400">+${linesAdded}</span>
                <span class="text-red-400">-${linesRemoved}</span>
                <span>lines</span>
            `;

            // Update policy status
            if (policy) {
                if (policy.allowed) {
                    policyStatusIcon.textContent = '‚úì';
                    policyStatusIcon.className = 'text-green-400';
                    policyStatusText.textContent = 'Safe to apply';
                    policyStatusText.className = 'text-gray-300';
                    btnApplyChanges.className = 'flex-1 bg-green-600 hover:bg-green-700 text-white text-xs font-medium px-3 py-2 rounded-lg transition-colors duration-200 flex items-center justify-center gap-1';
                } else {
                    policyStatusIcon.textContent = '‚ö†';
                    policyStatusIcon.className = 'text-amber-400';
                    policyStatusText.textContent = policy.reasons ? policy.reasons.join('; ') : 'Manual review required';
                    policyStatusText.className = 'text-amber-300';
                    btnApplyChanges.className = 'flex-1 bg-amber-600 hover:bg-amber-700 text-white text-xs font-medium px-3 py-2 rounded-lg transition-colors duration-200 flex items-center justify-center gap-1';
                }
            }

            btnApplyChanges.disabled = false;
        }

        // Handle messages from the extension
        window.addEventListener('message', event => {
            const message = event.data;
            console.log('Received message from extension:', message);
            switch (message.command) {
                case 'updatePermissions':
                    console.log('Updating permissions:', message.permissions);
                    updateUIForPermissions(message.permissions);
                    break;
                case 'showCurrentChange':
                    // Sequential review mode: show one change at a time
                    updateCurrentChangeUI(
                        message.currentChange,
                        message.currentIndex,
                        message.totalChanges,
                        message.policyResult
                    );

                    // If auto-apply is enabled and policy allows, apply automatically
                    if (autoApplyEnabled && message.policyResult && message.policyResult.allowed) {
                        vscode.postMessage({ command: 'applyChanges', changeSet: { changes: [message.currentChange] } });
                    }
                    break;
                case 'allChangesComplete':
                    // All changes have been reviewed
                    clearPendingChanges();
                    break;
                case 'changesGenerated':
                    // Legacy: Store the pending change set (kept for backwards compatibility)
                    pendingChangeSet = message.changeSet;
                    policyResult = message.policyResult;
                    // Don't call updatePendingChangesCard here anymore
                    // The showCurrentChange message will handle the UI update
                    break;
                case 'changesApplied':
                    // Single change applied, waiting for next showCurrentChange or allChangesComplete
                    break;
                case 'autoApplyState':
                    autoApplyEnabled = message.enabled;
                    autoApplyToggle.checked = autoApplyEnabled;
                    break;
                case 'endChatConfirmed':
                    handleEndChatConfirmed();
                    break;
                case 'conductorStateChanged':
                    render(message.state, message.session);
                    break;
                case 'uploadFileResult':
                    handleUploadFileResult(message);
                    break;
                case 'codeSnippet':
                    // Received code snippet from extension (user selected code in editor)
                    handleCodeSnippetFromExtension(message);
                    break;
            }
        });

        /**
         * Handle file upload result from extension host
         */
        function handleUploadFileResult(message) {
            console.log('[WebView] Upload result received:', message);

            if (message.success) {
                const result = message.result;
                console.log('[WebView] File uploaded successfully:', result);
                console.log('[WebView] WebSocket state:', ws ? ws.readyState : 'null', '(OPEN=1)');

                // Send file message via WebSocket
                // SECURITY: userId and role are assigned by backend
                if (ws && ws.readyState === WebSocket.OPEN) {
                    const fileMessage = {
                        type: 'file',
                        id: crypto.randomUUID ? crypto.randomUUID() : Date.now().toString(),
                        displayName: session.displayName || 'User',
                        fileId: result.id,
                        originalFilename: result.original_filename,
                        fileType: result.file_type,
                        mimeType: result.mime_type,
                        sizeBytes: result.size_bytes,
                        downloadUrl: result.download_url,
                        caption: pendingUploadCaption,
                        ts: Date.now() / 1000
                    };

                    console.log('[WebView] Sending file message via WebSocket:', fileMessage);
                    ws.send(JSON.stringify(fileMessage));
                    console.log('[WebView] File message sent successfully');
                } else {
                    console.error('[WebView] Cannot send file message: WebSocket not open. ws:', ws, 'readyState:', ws?.readyState);
                }

                // Clear preview after successful upload
                clearFilePreview();
                pendingUploadCaption = null;
                console.log('[WebView] File upload complete, preview cleared');
            } else {
                console.error('[WebView] File upload failed:', message.error);
                alert(`File upload failed: ${message.error}`);
                // Reset upload state but keep preview so user can retry
                isUploading = false;
                btnUploadFile.disabled = false;
                btnUploadFile.textContent = '‚¨ÜÔ∏è Upload';
            }
        }

        // ----- Conductor session button handlers -----

        // Idle panel: Start (triggers health check ‚Üí ReadyToHost ‚Üí startSession)
        btnIdleStart.addEventListener('click', () => {
            vscode.postMessage({ command: 'startSession' });
        });

        // Idle panel: Join (paste invite URL)
        btnIdleJoin.addEventListener('click', () => {
            const url = inviteUrlInput.value.trim();
            if (!url) { return; }
            vscode.postMessage({ command: 'joinSession', inviteUrl: url });
            inviteUrlInput.value = '';
        });

        // BackendDisconnected panel: Retry
        btnRetry.addEventListener('click', () => {
            vscode.postMessage({ command: 'retryConnection' });
        });

        // BackendDisconnected panel: Join (paste invite URL)
        btnDisconnectedJoin.addEventListener('click', () => {
            const url = disconnectedInviteUrlInput.value.trim();
            if (!url) { return; }
            vscode.postMessage({ command: 'joinSession', inviteUrl: url });
            disconnectedInviteUrlInput.value = '';
        });

        // ReadyToHost panel: Start Session
        btnStartSession.addEventListener('click', () => {
            vscode.postMessage({ command: 'startSession' });
        });

        // ReadyToHost panel: Join (paste invite URL)
        btnReadyJoin.addEventListener('click', () => {
            const url = readyInviteUrlInput.value.trim();
            if (!url) { return; }
            vscode.postMessage({ command: 'joinSession', inviteUrl: url });
            readyInviteUrlInput.value = '';
        });

        // Hosting: Stop + Copy Invite
        btnStopSession.addEventListener('click', () => {
            vscode.postMessage({ command: 'stopSession' });
        });

        btnCopyInvite.addEventListener('click', () => {
            vscode.postMessage({ command: 'copyInviteLink' });
        });

        // Joined: Leave
        btnLeaveSession.addEventListener('click', () => {
            vscode.postMessage({ command: 'leaveSession' });
        });

        // Button click handlers
        btnCreateSummary.addEventListener('click', () => {
            vscode.postMessage({ command: 'alert', text: 'Create Summary clicked (Lead feature)' });
        });

        btnGenerateChanges.addEventListener('click', () => {
            // Trigger generate changes - will use the active editor's file
            vscode.postMessage({ command: 'generateChanges' });
        });

        // Auto-apply toggle handler
        autoApplyToggle.addEventListener('change', (e) => {
            autoApplyEnabled = e.target.checked;
            vscode.postMessage({ command: 'setAutoApply', enabled: autoApplyEnabled });
        });

        // Pending changes card button handlers
        btnViewDiff.addEventListener('click', () => {
            // View diff for current change only
            if (currentChange) {
                vscode.postMessage({ command: 'viewDiff', changeSet: { changes: [currentChange], summary: '' } });
            } else if (pendingChangeSet) {
                vscode.postMessage({ command: 'viewDiff', changeSet: pendingChangeSet });
            }
        });

        btnApplyChanges.addEventListener('click', () => {
            // Apply current change only (the extension handles the queue)
            if (currentChange) {
                vscode.postMessage({ command: 'applyChanges', changeSet: { changes: [currentChange], summary: '' } });
            } else if (pendingChangeSet) {
                vscode.postMessage({ command: 'applyChanges', changeSet: pendingChangeSet });
            }
        });

        btnDiscardChanges.addEventListener('click', () => {
            clearPendingChanges();
            vscode.postMessage({ command: 'discardChanges' });
        });

        // Initialize with permissions from the extension
        if (window.initialPermissions) {
            updateUIForPermissions(window.initialPermissions);
        } else {
            // Request permissions if not injected
            vscode.postMessage({ command: 'getPermissions' });
        }

        // Request auto-apply state
        vscode.postMessage({ command: 'getAutoApplyState' });

        // =====================================================
        // WebSocket Chat Implementation
        // =====================================================

        // Intersection Observer for read receipts
        let messageReadObserver = null;
        const readMessageIds = new Set();  // Track which messages we've already sent read receipts for

        /**
         * Initialize Intersection Observer for read receipts.
         * Called once when messages container is available.
         */
        function initReadReceiptObserver() {
            if (messageReadObserver) return;  // Already initialized

            messageReadObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const messageId = entry.target.getAttribute('data-message-id');
                        if (messageId && !readMessageIds.has(messageId)) {
                            readMessageIds.add(messageId);
                            sendReadReceipt(messageId);
                            // Stop observing this message
                            messageReadObserver.unobserve(entry.target);
                        }
                    }
                });
            }, {
                root: messagesContainer,
                threshold: 0.5  // Message is 50% visible
            });
        }

        // Initialize observer when DOM is ready
        initReadReceiptObserver();

        /**
         * Format timestamp for display
         */
        function formatTime(ts) {
            const date = new Date(ts * 1000);
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        /**
         * Escape HTML to prevent XSS
         */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Get initials from a display name
         */
        function getInitials(name) {
            return name.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2);
        }

        /**
         * Render the users list in the sidebar with enhanced status display
         */
        function renderUsersList(users) {
            usersMap.clear();
            users.forEach(u => usersMap.set(u.userId, u));

            // Update count badge
            userCount.textContent = users.length;

            // Update room ID display if available
            if (session.roomId) {
                const roomIdDisplay = document.getElementById('room-id-display');
                const shortId = session.roomId.slice(0, 8);
                roomIdDisplay.innerHTML = `Room: <span class="text-gray-400 font-mono">${shortId}...</span>`;
                roomIdDisplay.title = session.roomId;
            }

            usersList.innerHTML = users.map(user => {
                const colorClass = avatarColors[user.avatarColor] || 'bg-purple-600';
                const isHost = user.role === 'host';
                const isMe = user.userId === session.userId;
                const isTyping = typingUsers.has(user.userId);

                // Role badge
                let roleBadge = '';
                if (isHost) {
                    roleBadge = '<span class="ml-1 px-1.5 py-0.5 text-xs bg-amber-500/20 text-amber-400 rounded">Host</span>';
                }

                // Status indicator
                const statusDot = isTyping
                    ? '<span class="absolute bottom-0 right-0 w-2.5 h-2.5 bg-blue-500 rounded-full animate-pulse"></span>'
                    : '<span class="absolute bottom-0 right-0 w-2.5 h-2.5 bg-green-500 rounded-full border border-gray-800"></span>';

                // Typing status text
                const typingText = isTyping
                    ? '<span class="text-xs text-blue-400 italic">typing...</span>'
                    : '';

                return `
                    <div class="user-item flex items-center gap-2 p-2 rounded-lg transition-colors ${isMe ? 'bg-blue-900/30 border border-blue-800/30' : 'hover:bg-gray-700/30'}" data-user-id="${escapeHtml(user.userId)}">
                        <div class="relative flex-shrink-0">
                            <div class="w-8 h-8 ${colorClass} rounded-full flex items-center justify-center text-white text-xs font-medium shadow-sm">
                                ${getInitials(user.displayName)}
                            </div>
                            ${statusDot}
                        </div>
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center">
                                <span class="text-sm text-gray-200 truncate font-medium">${escapeHtml(user.displayName)}</span>
                                ${isMe ? '<span class="ml-1 text-xs text-gray-500">(you)</span>' : ''}
                            </div>
                            <div class="flex items-center gap-1 mt-0.5">
                                ${roleBadge}
                                ${typingText}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        /**
         * Format file size for display
         */
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        /**
         * Get file icon based on file type.
         * @param {string} fileType - File type (image, pdf, audio, other).
         * @returns {string} Emoji icon for the file type.
         */
        function getFileIcon(fileType) {
            switch (fileType) {
                case 'image': return 'üñºÔ∏è';
                case 'pdf': return 'üìÑ';
                case 'audio': return 'üéµ';
                default: return 'üìé';
            }
        }

        /**
         * Format a date for display as a date separator.
         * @param {Date} date - The date to format.
         * @returns {string} Formatted date string (e.g., "Today", "Yesterday", or "Feb 7, 2026").
         */
        function formatDateSeparator(date) {
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);

            if (date.toDateString() === today.toDateString()) {
                return 'Today';
            } else if (date.toDateString() === yesterday.toDateString()) {
                return 'Yesterday';
            } else {
                return date.toLocaleDateString([], { month: 'short', day: 'numeric', year: 'numeric' });
            }
        }

        /**
         * Render a date separator in the messages container.
         * @param {Date} date - The date for the separator.
         */
        function renderDateSeparator(date) {
            const div = document.createElement('div');
            div.className = 'flex justify-center my-4';
            div.innerHTML = `
                <span class="text-xs text-gray-500 bg-gray-800 px-3 py-1 rounded-full border border-gray-700">
                    ${formatDateSeparator(date)}
                </span>
            `;
            messagesContainer.appendChild(div);
        }

        /**
         * Update the typing indicator display.
         * Shows which users are currently typing.
         */
        function updateTypingIndicator() {
            if (typingUsers.size === 0) {
                typingIndicator.classList.add('hidden');
                return;
            }

            const names = Array.from(typingUsers.values());
            let text;
            if (names.length === 1) {
                text = `${names[0]} is typing...`;
            } else if (names.length === 2) {
                text = `${names[0]} and ${names[1]} are typing...`;
            } else {
                text = `${names[0]} and ${names.length - 1} others are typing...`;
            }

            typingText.textContent = text;
            typingIndicator.classList.remove('hidden');
        }

        /**
         * Handle incoming typing indicator from another user.
         * Updates both the typing indicator and user list to show typing status.
         * @param {Object} data - Typing event data with userId, displayName, isTyping.
         */
        function handleTypingEvent(data) {
            if (data.isTyping) {
                typingUsers.set(data.userId, data.displayName);
                // Auto-expire after TYPING_EXPIRE_MS
                setTimeout(() => {
                    typingUsers.delete(data.userId);
                    updateTypingIndicator();
                    updateUserTypingStatus(data.userId, false);
                }, TYPING_EXPIRE_MS);
            } else {
                typingUsers.delete(data.userId);
            }
            updateTypingIndicator();
            updateUserTypingStatus(data.userId, data.isTyping);
        }

        /**
         * Update a specific user's typing status in the user list
         * without re-rendering the entire list
         */
        function updateUserTypingStatus(userId, isTyping) {
            const userItem = usersList.querySelector(`[data-user-id="${userId}"]`);
            if (!userItem) return;

            // Update status dot
            const statusDot = userItem.querySelector('.absolute');
            if (statusDot) {
                if (isTyping) {
                    statusDot.className = 'absolute bottom-0 right-0 w-2.5 h-2.5 bg-blue-500 rounded-full animate-pulse';
                } else {
                    statusDot.className = 'absolute bottom-0 right-0 w-2.5 h-2.5 bg-green-500 rounded-full border border-gray-800';
                }
            }

            // Update typing text
            const statusTextContainer = userItem.querySelector('.flex.items-center.gap-1.mt-0\\.5');
            if (statusTextContainer) {
                const existingTyping = statusTextContainer.querySelector('.italic');
                if (isTyping && !existingTyping) {
                    const typingSpan = document.createElement('span');
                    typingSpan.className = 'text-xs text-blue-400 italic';
                    typingSpan.textContent = 'typing...';
                    statusTextContainer.appendChild(typingSpan);
                } else if (!isTyping && existingTyping) {
                    existingTyping.remove();
                }
            }
        }

        /**
         * Send typing indicator to other users (debounced).
         * @param {boolean} isTyping - Whether the user is currently typing.
         */
        function sendTypingIndicator(isTyping) {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;

            // SECURITY: Backend uses assigned userId, we only send displayName
            ws.send(JSON.stringify({
                type: 'typing',
                displayName: session.displayName || 'Host',
                isTyping: isTyping
            }));
        }

        /**
         * Check if user is scrolled near the bottom of messages.
         * @returns {boolean} True if within SCROLL_THRESHOLD of bottom.
         */
        function isNearBottom() {
            const { scrollTop, scrollHeight, clientHeight } = messagesContainer;
            return scrollHeight - scrollTop - clientHeight < SCROLL_THRESHOLD;
        }

        /**
         * Update scroll-to-bottom button visibility and unread count.
         */
        function updateScrollButton() {
            if (isUserScrolledUp) {
                scrollToBottomBtn.classList.remove('hidden');
                if (unreadCount > 0) {
                    unreadCountBadge.textContent = unreadCount > 99 ? '99+' : unreadCount;
                    unreadCountBadge.classList.remove('hidden');
                } else {
                    unreadCountBadge.classList.add('hidden');
                }
            } else {
                scrollToBottomBtn.classList.add('hidden');
                unreadCount = 0;
            }
        }

        /**
         * Scroll to the bottom of messages container.
         * @param {boolean} force - Force scroll even if user scrolled up.
         */
        function scrollToBottom(force = true) {
            if (force || !isUserScrolledUp) {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                isUserScrolledUp = false;
                unreadCount = 0;
                updateScrollButton();
            }
        }

        /**
         * Smart scroll: scroll to bottom if user is near bottom, otherwise increment unread.
         * @param {boolean} isOwnMessage - True if this is the current user's message.
         */
        function smartScroll(isOwnMessage = false) {
            if (isOwnMessage || !isUserScrolledUp) {
                scrollToBottom(true);
            } else {
                unreadCount++;
                updateScrollButton();
            }
        }

        /**
         * Handle scroll event on messages container.
         * Triggers pagination when scrolled near top.
         */
        function handleScroll() {
            isUserScrolledUp = !isNearBottom();
            if (!isUserScrolledUp) {
                unreadCount = 0;
            }
            updateScrollButton();

            // Trigger pagination when scrolled near top
            if (messagesContainer.scrollTop < PAGINATION_THRESHOLD && hasMoreHistory && !isLoadingHistory) {
                loadMoreHistory();
            }
        }

        /**
         * Handle input event for typing indicator.
         * Debounces typing indicator messages and auto-resizes textarea.
         */
        function handleInputEvent() {
            const now = Date.now();

            // Auto-resize textarea
            chatInput.style.height = 'auto';
            chatInput.style.height = Math.min(chatInput.scrollHeight, 150) + 'px';

            // Send typing indicator (debounced)
            if (!isTyping) {
                isTyping = true;
                sendTypingIndicator(true);
            }
            lastTypingTime = now;

            // Clear existing timeout and set new one
            if (typingTimeout) clearTimeout(typingTimeout);
            typingTimeout = setTimeout(() => {
                if (Date.now() - lastTypingTime >= TYPING_DEBOUNCE_MS && isTyping) {
                    isTyping = false;
                    sendTypingIndicator(false);
                }
            }, TYPING_DEBOUNCE_MS);
        }

        /**
         * Check if a message should be grouped with the previous message.
         * Messages from the same user within MESSAGE_GROUP_INTERVAL_MS are grouped.
         * @param {Object} msg - Message object with userId and ts.
         * @returns {boolean} True if message should be grouped.
         */
        function shouldGroupMessage(msg) {
            const msgTime = msg.ts * 1000;
            const sameUser = msg.userId === lastMessageUserId;
            const withinInterval = (msgTime - lastMessageTime) < MESSAGE_GROUP_INTERVAL_MS;
            return sameUser && withinInterval;
        }

        /**
         * Check if a date separator is needed before this message.
         * @param {Object} msg - Message object with ts timestamp.
         * @returns {boolean} True if a date separator should be rendered.
         */
        function needsDateSeparator(msg) {
            const msgDate = new Date(msg.ts * 1000);
            const msgDateStr = msgDate.toDateString();

            if (lastMessageDate !== msgDateStr) {
                lastMessageDate = msgDateStr;
                return true;
            }
            return false;
        }

        /**
         * Render a code snippet message in the UI.
         * @param {Object} msg - Message object with codeSnippet data.
         */
        function renderCodeSnippetMessage(msg) {
            const isOwnMessage = msg.userId === session.userId;
            const isGrouped = shouldGroupMessage(msg);

            // Update grouping state for next message
            lastMessageUserId = msg.userId;
            lastMessageTime = msg.ts * 1000;

            const div = document.createElement('div');
            div.setAttribute('data-message-id', msg.id || '');
            div.setAttribute('data-timestamp', msg.ts || '');
            div.className = `flex ${isOwnMessage ? 'justify-end' : 'justify-start'} gap-2 ${isGrouped ? 'mt-1' : ''}`;

            const timeAlign = isOwnMessage ? 'text-right' : '';
            const roleLabel = msg.role === 'host' ? 'üëë ' : '';
            const displayName = msg.displayName || usersMap.get(msg.userId)?.displayName || 'Unknown';

            // Get avatar color from users map or default
            const userInfo = usersMap.get(msg.userId);
            const colorClass = userInfo ? (avatarColors[userInfo.avatarColor] || 'bg-purple-600') : 'bg-gray-600';

            // Hide avatar and name for grouped messages
            const avatarHtml = (!isOwnMessage && !isGrouped) ? `
                <div class="w-7 h-7 ${colorClass} rounded-full flex items-center justify-center text-white text-xs font-medium flex-shrink-0 mt-1">
                    ${getInitials(displayName)}
                </div>
            ` : (!isOwnMessage && isGrouped) ? '<div class="w-7 flex-shrink-0"></div>' : '';

            const showName = !isOwnMessage && !isGrouped;
            const snippet = msg.codeSnippet || {};
            const lineInfo = snippet.startLine === snippet.endLine
                ? `Line ${snippet.startLine}`
                : `Lines ${snippet.startLine}-${snippet.endLine}`;

            // Status indicator for own messages
            const statusHtml = isOwnMessage ? '<span class="message-status text-blue-300 ml-1">‚úì</span>' : '';

            // Comment text if any
            const commentHtml = msg.content ? `
                <p class="text-sm leading-relaxed break-words whitespace-pre-wrap mb-2">${escapeHtml(msg.content)}</p>
            ` : '';

            div.innerHTML = `
                ${avatarHtml}
                <div class="max-w-[85%] min-w-0">
                    ${showName ? `<div class="text-xs text-gray-400 mb-1 ml-1">${roleLabel}${escapeHtml(displayName)}</div>` : ''}
                    <div class="bg-gray-800 rounded-lg overflow-hidden border border-gray-700 shadow-lg">
                        ${commentHtml ? `<div class="px-4 py-2 border-b border-gray-700">${commentHtml}</div>` : ''}
                        <div class="flex items-center justify-between px-3 py-2 bg-gray-700/50 border-b border-gray-600">
                            <div class="flex items-center gap-2">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-blue-400" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M12.316 3.051a1 1 0 01.633 1.265l-4 12a1 1 0 11-1.898-.632l4-12a1 1 0 011.265-.633zM5.707 6.293a1 1 0 010 1.414L3.414 10l2.293 2.293a1 1 0 11-1.414 1.414l-3-3a1 1 0 010-1.414l3-3a1 1 0 011.414 0zm8.586 0a1 1 0 011.414 0l3 3a1 1 0 010 1.414l-3 3a1 1 0 11-1.414-1.414L16.586 10l-2.293-2.293a1 1 0 010-1.414z" clip-rule="evenodd" />
                                </svg>
                                <span class="text-xs text-gray-300 font-mono truncate max-w-[180px]" title="${escapeHtml(snippet.filename || '')}">${escapeHtml(snippet.relativePath || snippet.filename || 'code')}</span>
                                <span class="text-xs text-gray-500">${lineInfo}</span>
                            </div>
                        </div>
                        <pre class="p-3 text-xs font-mono text-gray-300 overflow-x-auto max-h-48 overflow-y-auto bg-gray-900/50"><code>${escapeHtml(snippet.code || '')}</code></pre>
                    </div>
                    <div class="text-xs text-gray-500 mt-0.5 ${timeAlign} ${isOwnMessage ? 'mr-1' : 'ml-1'} flex items-center ${isOwnMessage ? 'justify-end' : ''}">
                        <span>${formatTime(msg.ts)}</span>${statusHtml}
                    </div>
                </div>
            `;

            messagesContainer.appendChild(div);
            smartScroll(isOwnMessage);

            // Observe for read receipts (only for messages from others)
            if (!isOwnMessage && msg.id && messageReadObserver) {
                messageReadObserver.observe(div);
            }
        }

        /**
         * Render a file message in the UI.
         * @param {Object} msg - File message object.
         */
        function renderFileMessage(msg) {
            const isOwnMessage = msg.userId === session.userId;
            const div = document.createElement('div');
            div.className = `flex ${isOwnMessage ? 'justify-end' : 'justify-start'} gap-2`;

            const timeAlign = isOwnMessage ? 'text-right' : '';
            const roleLabel = msg.role === 'host' ? 'üëë ' : '';
            const displayName = msg.displayName || usersMap.get(msg.userId)?.displayName || 'Unknown';

            // Get avatar color from users map or default
            const userInfo = usersMap.get(msg.userId);
            const colorClass = userInfo ? (avatarColors[userInfo.avatarColor] || 'bg-purple-600') : 'bg-gray-600';

            const avatarHtml = !isOwnMessage ? `
                <div class="w-7 h-7 ${colorClass} rounded-full flex items-center justify-center text-white text-xs font-medium flex-shrink-0 mt-1">
                    ${getInitials(displayName)}
                </div>
            ` : '';

            // Build file content based on type
            let fileContentHtml = '';
            const filename = escapeHtml(msg.originalFilename || 'file');
            const fileSize = formatFileSize(msg.sizeBytes || 0);
            const downloadUrl = msg.downloadUrl || '';

            // Store file info for download handler (will be attached after innerHTML is set)
            const fileInfo = {
                fileId: msg.fileId,
                fileName: msg.originalFilename || 'file',
                downloadUrl: downloadUrl
            };

            if (msg.fileType === 'image') {
                // Image: show inline preview with download on click
                fileContentHtml = `
                    <div class="file-attachment">
                        <img src="${downloadUrl}" alt="${filename}"
                             class="max-w-full max-h-64 rounded-lg cursor-pointer hover:opacity-90 transition-opacity file-download-trigger"
                             data-file-id="${escapeHtml(msg.fileId || '')}"
                             data-file-name="${escapeHtml(msg.originalFilename || 'file')}"
                             data-download-url="${escapeHtml(downloadUrl)}"
                             onerror="this.onerror=null; this.src=''; this.alt='Image failed to load';" />
                        <div class="flex items-center gap-2 mt-2 text-xs text-gray-400">
                            <span>${filename}</span>
                            <span>¬∑</span>
                            <span>${fileSize}</span>
                            <span class="text-blue-400 cursor-pointer hover:underline file-download-trigger"
                                  data-file-id="${escapeHtml(msg.fileId || '')}"
                                  data-file-name="${escapeHtml(msg.originalFilename || 'file')}"
                                  data-download-url="${escapeHtml(downloadUrl)}">üì• Download</span>
                        </div>
                    </div>
                `;
            } else {
                // Other files: show download link
                const icon = getFileIcon(msg.fileType);
                fileContentHtml = `
                    <div class="file-attachment flex items-center gap-3 p-3 bg-gray-900/50 rounded-lg hover:bg-gray-900 transition-colors border border-gray-600 cursor-pointer file-download-trigger"
                         data-file-id="${escapeHtml(msg.fileId || '')}"
                         data-file-name="${escapeHtml(msg.originalFilename || 'file')}"
                         data-download-url="${escapeHtml(downloadUrl)}">
                        <span class="text-3xl">${icon}</span>
                        <div class="min-w-0 flex-1">
                            <div class="font-medium text-sm text-gray-200 truncate">${filename}</div>
                            <div class="text-xs text-gray-500">${fileSize}</div>
                        </div>
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-400" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                        </svg>
                    </div>
                `;
            }

            // Add caption if present
            const captionHtml = msg.caption ? `<p class="text-sm mt-2">${escapeHtml(msg.caption)}</p>` : '';

            div.innerHTML = `
                ${avatarHtml}
                <div class="max-w-[75%] min-w-0">
                    ${!isOwnMessage ? `<div class="text-xs text-gray-400 mb-1 ml-1">${roleLabel}${escapeHtml(displayName)}</div>` : ''}
                    <div class="bg-gray-800 text-gray-100 rounded-2xl ${isOwnMessage ? 'rounded-tr-sm' : 'rounded-tl-sm'} px-4 py-3 shadow-lg overflow-hidden border border-gray-700">
                        ${fileContentHtml}
                        ${captionHtml}
                    </div>
                    <div class="text-xs text-gray-500 mt-1 ${timeAlign} ${isOwnMessage ? 'mr-1' : 'ml-1'}">${formatTime(msg.ts)}</div>
                </div>
            `;

            messagesContainer.appendChild(div);
            smartScroll(isOwnMessage);

            // Attach click handlers to download triggers
            div.querySelectorAll('.file-download-trigger').forEach(el => {
                el.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const fileId = el.getAttribute('data-file-id');
                    const fileName = el.getAttribute('data-file-name');
                    const downloadUrl = el.getAttribute('data-download-url');

                    console.log('[WebView] Download requested:', { fileId, fileName, downloadUrl });

                    vscode.postMessage({
                        command: 'downloadFile',
                        fileId: fileId,
                        fileName: fileName,
                        downloadUrl: downloadUrl
                    });
                });
            });
        }

        /**
         * Render a chat message in the UI.
         * Includes message grouping and status indicators.
         * @param {Object} msg - Message object with id, userId, displayName, role, content, ts.
         */
        function renderMessage(msg) {
            // Check if we need a date separator
            if (needsDateSeparator(msg)) {
                renderDateSeparator(new Date(msg.ts * 1000));
            }

            const isOwnMessage = msg.userId === session.userId;
            const isGrouped = shouldGroupMessage(msg);

            // Update grouping state for next message
            lastMessageUserId = msg.userId;
            lastMessageTime = msg.ts * 1000;

            const div = document.createElement('div');
            div.setAttribute('data-message-id', msg.id || '');
            div.setAttribute('data-timestamp', msg.ts || '');
            // Reduce spacing for grouped messages
            div.className = `flex ${isOwnMessage ? 'justify-end' : 'justify-start'} gap-2 ${isGrouped ? 'mt-1' : ''}`;

            const bubbleColor = isOwnMessage
                ? 'bg-blue-600 text-white rounded-2xl rounded-tr-sm'
                : 'bg-gray-800 text-gray-100 rounded-2xl rounded-tl-sm border border-gray-700';

            const timeAlign = isOwnMessage ? 'text-right' : '';
            const roleLabel = msg.role === 'host' ? 'üëë ' : '';
            const displayName = msg.displayName || usersMap.get(msg.userId)?.displayName || 'Unknown';

            // Get avatar color from users map or default
            const userInfo = usersMap.get(msg.userId);
            const colorClass = userInfo ? (avatarColors[userInfo.avatarColor] || 'bg-purple-600') : 'bg-gray-600';

            // Hide avatar and name for grouped messages
            const avatarHtml = (!isOwnMessage && !isGrouped) ? `
                <div class="w-7 h-7 ${colorClass} rounded-full flex items-center justify-center text-white text-xs font-medium flex-shrink-0 mt-1">
                    ${getInitials(displayName)}
                </div>
            ` : (!isOwnMessage && isGrouped) ? '<div class="w-7 flex-shrink-0"></div>' : '';

            // Status indicator for own messages (‚úì = sent, ‚úì‚úì = read)
            const statusHtml = isOwnMessage ? '<span class="message-status text-blue-300 ml-1">‚úì</span>' : '';

            // Show name only for first message in group
            const showName = !isOwnMessage && !isGrouped;

            div.innerHTML = `
                ${avatarHtml}
                <div class="max-w-[75%] min-w-0">
                    ${showName ? `<div class="text-xs text-gray-400 mb-1 ml-1">${roleLabel}${escapeHtml(displayName)}</div>` : ''}
                    <div class="${bubbleColor} px-4 py-2 shadow-lg overflow-hidden">
                        <p class="text-sm leading-relaxed break-words whitespace-pre-wrap">${escapeHtml(msg.content)}</p>
                    </div>
                    <div class="text-xs text-gray-500 mt-0.5 ${timeAlign} ${isOwnMessage ? 'mr-1' : 'ml-1'} flex items-center ${isOwnMessage ? 'justify-end' : ''}">
                        <span>${formatTime(msg.ts)}</span>${statusHtml}
                    </div>
                </div>
            `;

            messagesContainer.appendChild(div);
            smartScroll(isOwnMessage);

            // Observe for read receipts (only for messages from others)
            if (!isOwnMessage && msg.id && messageReadObserver) {
                messageReadObserver.observe(div);
            }
        }

        /**
         * Render a system message (user joined/left)
         */
        function renderSystemMessage(text) {
            const div = document.createElement('div');
            div.className = 'flex justify-center';
            div.innerHTML = `
                <div class="bg-gray-800/50 text-gray-400 text-xs px-3 py-1.5 rounded-full border border-gray-700">
                    ${escapeHtml(text)}
                </div>
            `;
            messagesContainer.appendChild(div);
            scrollToBottom(false);  // System messages don't force scroll
        }

        /**
         * Load more message history (pagination).
         * Fetches older messages from the server and prepends them.
         */
        async function loadMoreHistory() {
            if (isLoadingHistory || !hasMoreHistory || !session.backendUrl || !session.roomId) {
                return;
            }

            isLoadingHistory = true;

            // Find the oldest message timestamp
            const messages = messagesContainer.querySelectorAll('[data-message-id]');
            if (messages.length === 0) {
                isLoadingHistory = false;
                return;
            }

            // Get timestamp from first message (oldest visible)
            const firstMessage = messages[0];
            const messageId = firstMessage.getAttribute('data-message-id');
            // We need to find the timestamp - look for it in the message data
            // For now, use the message ID to find timestamp from our tracking
            // Actually, we need to store timestamps. Let's use a different approach.

            // Find oldest timestamp from seenMessageIds is not possible.
            // We'll use lastMessageTimestamp tracking differently.
            // Let's add data-timestamp attribute to messages.

            // For now, use a simple approach: fetch with limit and check hasMore
            try {
                // Build URL - we need to get the oldest message's timestamp
                // Since we don't have it stored, we'll need to track it
                const oldestTs = getOldestMessageTimestamp();
                if (!oldestTs) {
                    isLoadingHistory = false;
                    hasMoreHistory = false;
                    return;
                }

                const url = `${session.backendUrl}/chat/${session.roomId}/history?before=${oldestTs}&limit=50`;
                console.log('[WebView] Loading more history from:', url);

                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();
                console.log('[WebView] Loaded history:', data.messages?.length, 'messages, hasMore:', data.hasMore);

                if (data.messages && data.messages.length > 0) {
                    // Save scroll position
                    const scrollHeight = messagesContainer.scrollHeight;

                    // Prepend messages (oldest first, so reverse to get chronological order)
                    const sortedMessages = data.messages.sort((a, b) => a.ts - b.ts);
                    sortedMessages.forEach(msg => {
                        if (!isDuplicateMessage(msg.id)) {
                            prependMessage(msg);
                        }
                    });

                    // Restore scroll position
                    messagesContainer.scrollTop = messagesContainer.scrollHeight - scrollHeight;
                }

                hasMoreHistory = data.hasMore === true;
            } catch (err) {
                console.error('[WebView] Failed to load history:', err);
            } finally {
                isLoadingHistory = false;
            }
        }

        /**
         * Get the timestamp of the oldest visible message.
         * @returns {number|null} Unix timestamp or null if no messages.
         */
        function getOldestMessageTimestamp() {
            const messages = messagesContainer.querySelectorAll('[data-timestamp]');
            if (messages.length === 0) return null;
            return parseFloat(messages[0].getAttribute('data-timestamp'));
        }

        /**
         * Prepend a message to the top of the messages container.
         * Similar to renderMessage but inserts at the beginning.
         * @param {Object} msg - Message object.
         */
        function prependMessage(msg) {
            const isOwnMessage = msg.userId === session.userId;

            const div = document.createElement('div');
            div.setAttribute('data-message-id', msg.id || '');
            div.setAttribute('data-timestamp', msg.ts || '');
            div.className = `flex ${isOwnMessage ? 'justify-end' : 'justify-start'} gap-2`;

            const bubbleColor = isOwnMessage
                ? 'bg-blue-600 text-white rounded-2xl rounded-tr-sm'
                : 'bg-gray-800 text-gray-100 rounded-2xl rounded-tl-sm border border-gray-700';

            const roleLabel = msg.role === 'host' ? 'üëë ' : '';
            const displayName = msg.displayName || usersMap.get(msg.userId)?.displayName || 'Unknown';
            const userInfo = usersMap.get(msg.userId);
            const colorClass = userInfo ? (avatarColors[userInfo.avatarColor] || 'bg-purple-600') : 'bg-gray-600';

            const avatarHtml = !isOwnMessage ? `
                <div class="w-7 h-7 ${colorClass} rounded-full flex items-center justify-center text-white text-xs font-medium flex-shrink-0 mt-1">
                    ${getInitials(displayName)}
                </div>
            ` : '';

            const statusHtml = isOwnMessage ? '<span class="message-status text-blue-300 ml-1">‚úì</span>' : '';
            const timeAlign = isOwnMessage ? 'text-right' : '';

            div.innerHTML = `
                ${avatarHtml}
                <div class="max-w-[75%] min-w-0">
                    ${!isOwnMessage ? `<div class="text-xs text-gray-400 mb-1 ml-1">${roleLabel}${escapeHtml(displayName)}</div>` : ''}
                    <div class="${bubbleColor} px-4 py-2 shadow-lg overflow-hidden">
                        <p class="text-sm leading-relaxed break-words whitespace-pre-wrap">${escapeHtml(msg.content)}</p>
                    </div>
                    <div class="text-xs text-gray-500 mt-0.5 ${timeAlign} ${isOwnMessage ? 'mr-1' : 'ml-1'} flex items-center ${isOwnMessage ? 'justify-end' : ''}">
                        <span>${formatTime(msg.ts)}</span>${statusHtml}
                    </div>
                </div>
            `;

            // Insert at the beginning
            messagesContainer.insertBefore(div, messagesContainer.firstChild);

            // Observe for read receipts
            if (!isOwnMessage && msg.id && messageReadObserver) {
                messageReadObserver.observe(div);
            }
        }

        /**
         * Update connection status display
         */
        function updateConnectionStatus(status, isError = false) {
            if (connectionStatus) {
                const colorClass = isError ? 'text-red-400 border-red-700' : 'text-gray-400 border-gray-700';
                connectionStatus.innerHTML = `
                    <div class="bg-gray-800/50 ${colorClass} text-xs px-3 py-1.5 rounded-full border">
                        <span>${status}</span>
                    </div>
                `;
            }
        }

        /**
         * Calculate reconnection delay with exponential backoff.
         * @returns {number} Delay in milliseconds.
         */
        function getReconnectDelay() {
            const delay = Math.min(
                BASE_RECONNECT_DELAY_MS * Math.pow(2, reconnectAttempts),
                MAX_RECONNECT_DELAY_MS
            );
            // Add jitter (¬±20%) to prevent thundering herd
            const jitter = delay * 0.2 * (Math.random() - 0.5);
            return Math.round(delay + jitter);
        }

        /**
         * Check if a message has already been rendered (for deduplication).
         * @param {string} messageId - The message ID to check.
         * @returns {boolean} True if duplicate, false if new.
         */
        function isDuplicateMessage(messageId) {
            if (!messageId) return false;
            if (seenMessageIds.has(messageId)) return true;
            seenMessageIds.add(messageId);
            // Limit set size to prevent memory issues
            if (seenMessageIds.size > 10000) {
                const first = seenMessageIds.values().next().value;
                seenMessageIds.delete(first);
            }
            return false;
        }

        /**
         * Track the timestamp of the latest message for reconnection recovery.
         * @param {number} ts - Unix timestamp in seconds.
         */
        function updateLastMessageTimestamp(ts) {
            if (ts > lastMessageTimestamp) {
                lastMessageTimestamp = ts;
            }
        }

        /**
         * Send a read receipt for a message.
         * @param {string} messageId - The message ID that was read.
         */
        function sendReadReceipt(messageId) {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            if (!messageId) return;

            // SECURITY: Backend uses assigned userId
            ws.send(JSON.stringify({
                type: 'read',
                messageId: messageId
            }));
        }

        /**
         * Connect to WebSocket chat server.
         * Supports message recovery on reconnect via `since` parameter.
         */
        function connectWebSocket() {
            if (!session.roomId || !session.userId) {
                console.error('[WebView] Cannot connect: missing roomId or userId');
                updateConnectionStatus('‚ùå Missing session info', true);
                return;
            }

            // Build WebSocket URL with optional `since` parameter for reconnection
            let wsUrl = session.backendUrl.replace('http', 'ws') + '/ws/chat/' + session.roomId;
            if (lastMessageTimestamp > 0 && reconnectAttempts > 0) {
                wsUrl += `?since=${lastMessageTimestamp}`;
                console.log('[WebView] Reconnecting with message recovery since:', lastMessageTimestamp);
            }
            console.log('[WebView] Connecting to:', wsUrl);
            updateConnectionStatus(reconnectAttempts > 0 ? 'Reconnecting...' : 'Connecting...');

            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('[WebView] WebSocket connected');
                reconnectAttempts = 0;
                updateConnectionStatus('‚úÖ Connected');
                // Hide status after a moment
                setTimeout(() => {
                    if (connectionStatus) connectionStatus.style.display = 'none';
                }, 2000);
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    console.log('[WebView] Received:', data);

                    // SECURITY: Handle backend-assigned credentials FIRST
                    // The backend assigns userId and role on connection - client MUST use these
                    if (data.type === 'connected') {
                        console.log('[WebView] SECURITY: Backend assigned credentials:', data);
                        // Store backend-assigned userId and role
                        session.userId = data.userId;
                        session.sessionRole = data.role;
                        console.log('[WebView] Updated session with backend credentials:', {
                            userId: session.userId,
                            sessionRole: session.sessionRole
                        });
                        // Don't send join yet - wait for history message
                    } else if (data.type === 'history') {
                        // Clear status
                        if (connectionStatus) connectionStatus.style.display = 'none';

                        // Render existing users (always update on history)
                        if (data.users) {
                            renderUsersList(data.users);
                        }

                        // Render message history (with deduplication)
                        data.messages.forEach(msg => {
                            if (!isDuplicateMessage(msg.id)) {
                                renderMessage(msg);
                                updateLastMessageTimestamp(msg.ts);
                            }
                        });

                        // Only send join if this is not a recovery (reconnect)
                        // SECURITY: Use backend-assigned userId (already stored in session)
                        if (!data.isRecovery) {
                            ws.send(JSON.stringify({
                                type: 'join',
                                displayName: session.displayName || 'User'
                                // Note: userId and role are now handled by backend
                            }));
                        }
                    } else if (data.type === 'message') {
                        if (!isDuplicateMessage(data.id)) {
                            renderMessage(data);
                            updateLastMessageTimestamp(data.ts);
                        }
                    } else if (data.type === 'file') {
                        if (!isDuplicateMessage(data.id)) {
                            renderFileMessage(data);
                            updateLastMessageTimestamp(data.ts);
                        }
                    } else if (data.type === 'code_snippet') {
                        if (!isDuplicateMessage(data.id)) {
                            renderCodeSnippetMessage(data);
                            updateLastMessageTimestamp(data.ts);
                        }
                    } else if (data.type === 'user_joined') {
                        renderUsersList(data.users);
                        renderSystemMessage(`${data.user.displayName} joined the chat`);
                    } else if (data.type === 'user_left') {
                        renderUsersList(data.users);
                        renderSystemMessage(`${data.user.displayName} left the chat`);
                    } else if (data.type === 'session_ended') {
                        sessionEnded = true;
                        renderSystemMessage('üî¥ ' + data.message);
                        // Disable input
                        chatInput.disabled = true;
                        chatInput.placeholder = 'Chat session has ended';
                        btnSend.disabled = true;
                        btnSend.classList.add('opacity-50', 'cursor-not-allowed');
                        // Hide end chat button
                        btnEndChat.classList.add('hidden');
                        // Clear users list
                        usersList.innerHTML = '';
                        userCount.textContent = '0 online';
                        // Notify extension to reset session state
                        vscode.postMessage({ command: 'sessionEnded' });
                    } else if (data.type === 'typing') {
                        handleTypingEvent(data);
                    } else if (data.type === 'read_receipt') {
                        // Update message status indicators
                        handleReadReceipt(data);
                    } else if (data.type === 'error') {
                        // SECURITY: Handle backend error messages (e.g., permission denied)
                        console.error('[WebView] Backend error:', data.error);
                        renderSystemMessage(`‚ö†Ô∏è ${data.error}`);
                    }
                } catch (err) {
                    console.error('[WebView] Failed to parse message:', err);
                }
            };

            ws.onclose = (event) => {
                console.log('[WebView] WebSocket closed:', event.code, event.reason);
                // Don't reconnect if session was ended by host
                if (sessionEnded) {
                    updateConnectionStatus('Session ended', false);
                    return;
                }
                if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                    reconnectAttempts++;
                    const delay = getReconnectDelay();
                    console.log(`[WebView] Reconnecting in ${delay}ms (attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);
                    updateConnectionStatus(`Reconnecting (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
                    setTimeout(connectWebSocket, delay);
                } else {
                    updateConnectionStatus('‚ùå Connection lost', true);
                }
            };

            ws.onerror = (error) => {
                console.error('[WebView] WebSocket error:', error);
                updateConnectionStatus('‚ùå Connection error', true);
            };
        }

        /**
         * Handle read receipt from server.
         * Updates message status indicators to show who has read.
         * @param {Object} data - Read receipt data with messageId and readBy.
         */
        function handleReadReceipt(data) {
            const { messageId, readBy } = data;
            if (!messageId || !readBy) return;

            // Find the message element and update its status
            const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
            if (messageEl) {
                const statusEl = messageEl.querySelector('.message-status');
                if (statusEl) {
                    // Show double checkmark if read by someone other than sender
                    const otherReaders = readBy.filter(id => id !== session.userId);
                    if (otherReaders.length > 0) {
                        statusEl.textContent = '‚úì‚úì';
                        statusEl.title = `Read by ${otherReaders.length} ${otherReaders.length === 1 ? 'person' : 'people'}`;
                    }
                }
            }
        }

        /**
         * Send a chat message.
         * Stops typing indicator and resets textarea.
         * Includes code snippet if one is attached.
         */
        function sendMessage() {
            const content = chatInput.value.trim();
            const hasSnippet = pendingCodeSnippet !== null;

            // Need either content or a code snippet to send
            if ((!content && !hasSnippet) || !ws || ws.readyState !== WebSocket.OPEN) {
                return;
            }

            // Stop typing indicator when sending message
            if (isTyping) {
                isTyping = false;
                sendTypingIndicator(false);
            }
            if (typingTimeout) {
                clearTimeout(typingTimeout);
                typingTimeout = null;
            }

            // Build message with optional code snippet
            // SECURITY: userId and role are assigned by backend, we only send content
            const message = {
                displayName: session.displayName || 'User',
                content: content || (hasSnippet ? '' : '')
            };

            // Attach code snippet if present
            if (hasSnippet) {
                message.type = 'code_snippet';
                message.codeSnippet = pendingCodeSnippet;
            }

            console.log('[WebView] Sending:', message);
            ws.send(JSON.stringify(message));
            chatInput.value = '';
            chatInput.style.height = 'auto';  // Reset textarea height

            // Clear code snippet after sending
            if (hasSnippet) {
                clearCodeSnippet();
            }
        }

        // Send button click handler (text messages only)
        btnSend.addEventListener('click', () => {
            sendMessage();
        });

        // Enter key handler (Shift+Enter for new line)
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // Input event handler for typing indicator and auto-resize
        chatInput.addEventListener('input', handleInputEvent);

        // Scroll event handler for scroll-to-bottom button
        messagesContainer.addEventListener('scroll', handleScroll);

        // Scroll to bottom button click handler
        scrollToBottomBtn.addEventListener('click', scrollToBottom);

        // ============================================================
        // Code Snippet Handling
        // ============================================================

        /**
         * Handle code snippet button click - request code from extension
         */
        btnCodeSnippet.addEventListener('click', () => {
            vscode.postMessage({ command: 'getCodeSnippet' });
        });

        /**
         * Handle code snippet received from extension
         */
        function handleCodeSnippetFromExtension(message) {
            if (message.error) {
                console.warn('[WebView] Code snippet error:', message.error);
                return;
            }

            pendingCodeSnippet = {
                filename: message.filename,
                relativePath: message.relativePath,
                language: message.language,
                startLine: message.startLine,
                endLine: message.endLine,
                code: message.code
            };

            // Show preview
            codeSnippetFilename.textContent = message.relativePath || message.filename;
            codeSnippetFilename.title = message.filename;
            codeSnippetLines.textContent = message.startLine === message.endLine
                ? `Line ${message.startLine}`
                : `Lines ${message.startLine}-${message.endLine}`;
            codeSnippetContent.textContent = message.code;
            codeSnippetPreview.classList.remove('hidden');

            // Focus the input for adding a comment
            chatInput.focus();
            chatInput.placeholder = 'Add a comment about this code...';
        }

        /**
         * Clear the pending code snippet
         */
        function clearCodeSnippet() {
            pendingCodeSnippet = null;
            codeSnippetPreview.classList.add('hidden');
            codeSnippetFilename.textContent = '';
            codeSnippetLines.textContent = '';
            codeSnippetContent.textContent = '';
            chatInput.placeholder = 'Type your message or paste an image...';
        }

        /**
         * Clear snippet button handler
         */
        btnClearSnippet.addEventListener('click', clearCodeSnippet);

        // ============================================================
        // File Upload Handling
        // ============================================================

        /**
         * Show file preview before upload
         */
        function showFilePreview(file) {
            pendingFile = file;
            filePreviewName.textContent = file.name;
            filePreviewSize.textContent = formatFileSize(file.size);

            // Set icon based on file type
            if (file.type.startsWith('image/')) {
                filePreviewIcon.textContent = 'üñºÔ∏è';
                // Show image thumbnail
                const reader = new FileReader();
                reader.onload = (e) => {
                    filePreviewImg.src = e.target.result;
                    filePreviewImg.classList.remove('hidden');
                };
                reader.readAsDataURL(file);
            } else if (file.type === 'application/pdf') {
                filePreviewIcon.textContent = 'üìÑ';
                filePreviewImg.classList.add('hidden');
            } else if (file.type.startsWith('audio/')) {
                filePreviewIcon.textContent = 'üéµ';
                filePreviewImg.classList.add('hidden');
            } else {
                filePreviewIcon.textContent = 'üìé';
                filePreviewImg.classList.add('hidden');
            }

            filePreview.classList.remove('hidden');
        }

        /**
         * Clear file preview
         */
        function clearFilePreview() {
            pendingFile = null;
            isUploading = false;
            filePreview.classList.add('hidden');
            filePreviewImg.src = '';
            filePreviewImg.classList.add('hidden');
            fileInput.value = '';
            fileCaption.value = '';
            btnUploadFile.disabled = false;
            btnUploadFile.textContent = '‚¨ÜÔ∏è Upload';
        }

        /**
         * Upload a file to the backend via VS Code extension host
         * (WebView cannot make direct fetch requests due to CORS restrictions)
         */
        async function uploadFile(file, caption = null) {
            // Prevent double uploads
            if (isUploading) {
                console.log('[WebView] Upload already in progress, ignoring');
                return;
            }

            console.log('[WebView] uploadFile called with:', file?.name, 'caption:', caption);
            console.log('[WebView] Session state:', {
                backendUrl: session.backendUrl,
                roomId: session.roomId,
                userId: session.userId,
                displayName: session.displayName
            });

            if (!session.backendUrl || !session.roomId) {
                console.error('[WebView] Cannot upload: missing backendUrl or roomId');
                alert('Cannot upload: session not initialized. Please start or join a session first.');
                return;
            }

            // Mark as uploading
            isUploading = true;
            btnUploadFile.disabled = true;
            btnUploadFile.textContent = '‚è≥ Uploading...';

            // Validate file size
            if (file.size > MAX_FILE_SIZE) {
                alert(`File size exceeds 20MB limit. Your file is ${formatFileSize(file.size)}`);
                isUploading = false;
                btnUploadFile.disabled = false;
                btnUploadFile.textContent = '‚¨ÜÔ∏è Upload';
                return;
            }

            // Store caption for use in response handler
            pendingUploadCaption = caption;

            try {
                console.log('[WebView] Uploading file via extension host:', file.name, file.size, 'bytes');

                // Convert file to base64 for sending via postMessage
                const reader = new FileReader();
                reader.onload = function(e) {
                    const base64Data = e.target.result.split(',')[1]; // Remove data URL prefix

                    // Send upload request to extension host
                    vscode.postMessage({
                        command: 'uploadFile',
                        backendUrl: session.backendUrl,
                        roomId: session.roomId,
                        userId: session.userId,
                        displayName: session.displayName || 'Host',
                        fileData: base64Data,
                        fileName: file.name,
                        mimeType: file.type || 'application/octet-stream',
                        caption: caption
                    });

                    console.log('[WebView] Upload request sent to extension host');
                };
                reader.onerror = function(e) {
                    console.error('[WebView] Failed to read file:', e);
                    alert('Failed to read file');
                    isUploading = false;
                    btnUploadFile.disabled = false;
                    btnUploadFile.textContent = '‚¨ÜÔ∏è Upload';
                };
                reader.readAsDataURL(file);

            } catch (error) {
                console.error('[WebView] File upload failed:', error);
                alert(`File upload failed: ${error.message}`);
                isUploading = false;
                btnUploadFile.disabled = false;
                btnUploadFile.textContent = '‚¨ÜÔ∏è Upload';
            }
        }

        // Store pending upload caption for use in response handler
        let pendingUploadCaption = null;

        // Attachment button click handler
        btnAttach.addEventListener('click', () => {
            fileInput.click();
        });

        // Upload button click handler (explicit upload action)
        btnUploadFile.addEventListener('click', async () => {
            if (pendingFile && !isUploading) {
                const caption = fileCaption.value.trim() || null;
                await uploadFile(pendingFile, caption);
            }
        });

        // File input change handler
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            if (file.size > MAX_FILE_SIZE) {
                alert(`File size exceeds 20MB limit. Your file is ${formatFileSize(file.size)}`);
                fileInput.value = '';
                return;
            }

            showFilePreview(file);
        });

        // Remove file button handler
        btnRemoveFile.addEventListener('click', clearFilePreview);

        // Handle paste event for images
        chatInput.addEventListener('paste', async (e) => {
            const items = e.clipboardData?.items;
            if (!items) return;

            for (const item of items) {
                if (item.type.startsWith('image/')) {
                    e.preventDefault();
                    const file = item.getAsFile();
                    if (file) {
                        // Show preview for pasted image
                        showFilePreview(file);
                    }
                    break;
                }
            }
        });

        // Copy room ID button handler
        btnCopyRoomId.addEventListener('click', async () => {
            if (session.roomId) {
                try {
                    await navigator.clipboard.writeText(session.roomId);
                    // Visual feedback - show checkmark
                    btnCopyRoomId.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-3.5 w-3.5 text-green-400" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
                        </svg>
                    `;
                    // Revert to clipboard icon after 2 seconds
                    setTimeout(() => {
                        btnCopyRoomId.innerHTML = `
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-3.5 w-3.5" viewBox="0 0 20 20" fill="currentColor">
                                <path d="M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z" />
                                <path d="M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z" />
                            </svg>
                        `;
                    }, 2000);
                } catch (err) {
                    console.error('Failed to copy room ID:', err);
                }
            }
        });

        // End chat button handler (Lead/Host only)
        btnEndChat.addEventListener('click', () => {
            console.log('[WebView] End Chat button clicked');
            // Use VS Code API for confirmation since confirm() doesn't work in WebView
            vscode.postMessage({
                command: 'confirmEndChat'
            });
        });

        // Handle confirmation response from extension
        function handleEndChatConfirmed() {
            console.log('[WebView] End chat confirmed, ws state:', ws ? ws.readyState : 'null');
            // SECURITY: Backend validates permission using assigned userId
            if (ws && ws.readyState === WebSocket.OPEN) {
                const msg = {
                    type: 'end_session'
                    // Note: userId is handled by backend (assigned on connection)
                };
                console.log('[WebView] Sending end_session:', msg);
                ws.send(JSON.stringify(msg));
            } else {
                console.error('[WebView] WebSocket not open');
            }
        }

        // Initialize UI from the current FSM state
        render(conductorState, null);

        // Request latest conductor state from extension (in case it changed since HTML was built)
        vscode.postMessage({ command: 'getConductorState' });
    </script>
</body>
</html>

