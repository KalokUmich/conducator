/**
 * @deprecated Use backend RAG (ragClient.ts) instead. This client-side vector
 * index is superseded by the FAISS-based backend pipeline (2.2).
 *
 * Local semantic search engine for Conductor V1.
 *
 * Loads pre-computed embedding vectors from SQLite, normalises them once
 * (so cosine similarity reduces to a plain dot product), then provides
 * sub-10 ms brute-force search over up to 5 000 vectors.
 *
 * Architecture constraints
 * ------------------------
 * - Query embeddings are generated by the backend (POST /embeddings).
 * - This module only does local storage + retrieval — no cloud calls.
 * - Pure semantic scoring: output is ordered by cosine similarity only.
 *   Structural re-ranking (same file, same module …) is left to the caller.
 *
 * Performance design
 * ------------------
 * 1. Flat interleaved buffer `_data: Float32Array` of shape [N × dim].
 *    All N vectors are stored contiguously for cache-friendly iteration.
 * 2. Vectors are L2-normalised once at load time; cosine similarity then
 *    equals a simple dot product (no division in the hot path).
 * 3. Scratch buffers `_scores` and `_indices` are pre-allocated at load
 *    time and reused across every `search()` call — zero heap allocation
 *    inside either the dot-product loop or the index-sort loop.
 * 4. Query normalisation copies the query vector once, outside the loop.
 *
 * No VS Code dependency — fully testable under the Node.js test runner.
 *
 * @module services/vectorIndex
 */

import { ConductorDb, SymbolVectorRow } from './conductorDb';

// ---------------------------------------------------------------------------
// Public types
// ---------------------------------------------------------------------------

export interface SearchResult {
    symbol_id: string;
    /**
     * Cosine similarity in the range [-1, 1].
     * 1.0 = identical direction, 0.0 = orthogonal, -1.0 = opposite direction.
     */
    score: number;
}

/**
 * Minimal structural type accepted by `VectorIndex.loadRows()`.
 * Compatible with `SymbolVectorRow` and with plain test fixtures.
 */
export interface VectorRow {
    symbol_id: string;
    dim: number;
    /** Raw `Float32Array` bytes (little-endian IEEE 754). */
    vector: { buffer: ArrayBufferLike; byteOffset: number };
}

// ---------------------------------------------------------------------------
// Private helpers (module-scope, no closures over instance state)
// ---------------------------------------------------------------------------

/**
 * L2-normalise `v` in-place: `v ← v / ‖v‖`.
 * A zero-length vector is left unchanged (avoids NaN).
 */
function normalizeInPlace(v: Float32Array): void {
    let sumSq = 0;
    for (let i = 0; i < v.length; i++) sumSq += v[i] * v[i];
    if (sumSq < 1e-20) return; // zero / near-zero vector — leave as-is
    const invLen = 1 / Math.sqrt(sumSq);
    for (let i = 0; i < v.length; i++) v[i] *= invLen;
}

const LOG = '[VectorIndex]';

// ---------------------------------------------------------------------------
// VectorIndex
// ---------------------------------------------------------------------------

export class VectorIndex {
    // ---- Flat interleaved storage -----------------------------------------
    // _data[i*dim .. (i+1)*dim-1] holds the normalised vector for symbol _ids[i].
    private _data: Float32Array  = new Float32Array(0);
    private _ids:  string[]      = [];
    private _dim:  number        = 0;
    private _size: number        = 0;

    // ---- Reusable scratch buffers (zero allocation inside search loops) ----
    private _scores:  Float32Array = new Float32Array(0);
    private _indices: Uint32Array  = new Uint32Array(0);

    // -----------------------------------------------------------------------
    // Properties
    // -----------------------------------------------------------------------

    /** Number of vectors currently in the index. */
    get size(): number { return this._size; }

    /** Dimensionality of each vector (0 when the index is empty). */
    get dim(): number { return this._dim; }

    // -----------------------------------------------------------------------
    // Loading
    // -----------------------------------------------------------------------

    /**
     * Load (or reload) all vectors for `model` from the database.
     *
     * Only rows whose `model` column matches are loaded; rows for other
     * models are ignored.  Vectors are normalised in-place immediately after
     * copying so that `search()` can use bare dot products.
     *
     * @param db     Open ConductorDb instance.
     * @param model  Embedding model ID, e.g. `"cohere.embed-v4"`.
     */
    load(db: ConductorDb, model: string): void {
        const rows = db.getAllVectorsByModel(model);
        console.log(`${LOG} loading ${rows.length} vector(s) for model=${model}`);
        this.loadRows(rows);
    }

    /**
     * Build the index from an array of vector rows.
     *
     * This is the core loading routine, separated from the DB call so that
     * tests can inject synthetic rows without touching the file system.
     *
     * Rows with a `dim` that differs from the first row's `dim` are skipped
     * and a warning is logged.  An empty input resets the index.
     *
     * @param rows  Array of row objects conforming to `VectorRow`.
     */
    loadRows(rows: VectorRow[]): void {
        if (rows.length === 0) {
            this._resetEmpty();
            return;
        }

        const dim = rows[0].dim;
        if (dim <= 0) {
            console.warn(`${LOG} loadRows: first row has dim=${dim}, skipping`);
            this._resetEmpty();
            return;
        }

        // Single allocation for the entire data buffer.
        const data    = new Float32Array(rows.length * dim);
        const ids     = new Array<string>(rows.length);
        let   count   = 0;

        for (let i = 0; i < rows.length; i++) {
            const row = rows[i];

            if (row.dim !== dim) {
                console.warn(
                    `${LOG} skipping ${row.symbol_id}: dim=${row.dim} expected ${dim}`,
                );
                continue;
            }

            // View the source bytes as Float32 values.
            const src = new Float32Array(row.vector.buffer, row.vector.byteOffset, dim);

            // Write into the flat buffer and normalise in-place.
            const dst = data.subarray(count * dim, (count + 1) * dim);
            dst.set(src);
            normalizeInPlace(dst);

            ids[count] = row.symbol_id;
            count++;
        }

        // Trim the data buffer if any rows were skipped.
        this._data = count === rows.length ? data : data.slice(0, count * dim);
        this._ids  = count === rows.length ? ids  : ids.slice(0, count);
        this._dim  = dim;
        this._size = count;

        // Allocate scratch buffers sized to the index.
        this._scores  = new Float32Array(count);
        this._indices = new Uint32Array(count);

        console.log(`${LOG} index ready: size=${count} dim=${dim}`);
    }

    // -----------------------------------------------------------------------
    // Search
    // -----------------------------------------------------------------------

    /**
     * Return the `topK` symbols whose normalised embedding vectors are most
     * similar to `queryVector`, ordered by descending cosine similarity.
     *
     * The query vector is normalised internally — the caller's buffer is
     * never mutated.
     *
     * Returns `[]` when the index is empty, `topK ≤ 0`, or the query
     * dimensionality does not match the index.
     *
     * @param queryVector  Raw (unnormalised) embedding from the backend.
     * @param topK         Maximum number of results to return.
     */
    search(queryVector: Float32Array, topK: number): SearchResult[] {
        if (this._size === 0 || topK <= 0) return [];

        if (queryVector.length !== this._dim) {
            console.warn(
                `${LOG} search: query dim=${queryVector.length} does not match index dim=${this._dim}`,
            );
            return [];
        }

        // --- Normalise a copy of the query (one allocation, outside the hot loop) ---
        const q = new Float32Array(this._dim);
        q.set(queryVector);
        normalizeInPlace(q);

        // --- Hot path: compute all dot products --------------------------------
        //
        // No object/array allocation inside either loop.
        // _data is a contiguous Float32Array; sequential access is cache-friendly.
        //
        const data    = this._data;
        const scores  = this._scores;
        const size    = this._size;
        const dim     = this._dim;

        for (let i = 0; i < size; i++) {
            const base = i * dim;
            let dot = 0;
            for (let j = 0; j < dim; j++) {
                dot += data[base + j] * q[j];
            }
            scores[i] = dot;
        }

        // --- Sort indices by descending score ----------------------------------
        //
        // Re-initialise the index buffer, then sort in-place using the reused
        // Uint32Array.  The comparator reads from `scores` (Float32Array);
        // V8 inlines such short comparators well.
        //
        const indices = this._indices;
        for (let i = 0; i < size; i++) indices[i] = i;
        indices.sort((a, b) => scores[b] - scores[a]);

        // --- Assemble results (O(K) object allocations, K << N) ---------------
        const k = Math.min(topK, size);
        const results: SearchResult[] = new Array(k);
        for (let i = 0; i < k; i++) {
            const idx = indices[i];
            results[i] = { symbol_id: this._ids[idx], score: scores[idx] };
        }
        return results;
    }

    // -----------------------------------------------------------------------
    // Private helpers
    // -----------------------------------------------------------------------

    private _resetEmpty(): void {
        this._data    = new Float32Array(0);
        this._ids     = [];
        this._dim     = 0;
        this._size    = 0;
        this._scores  = new Float32Array(0);
        this._indices = new Uint32Array(0);
    }
}
